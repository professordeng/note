---
title: 3.6 高速缓冲寄存器
date: 2019-11-16
---

由于程序的转移概率不会很低，数据分布的离散性较大，所以单纯依靠并行主存系统提高主存系统的频宽是有限的。这就必须从系统结构上进行改进，即采用存储体系。通常将存储系统分为 “Cache-主存” 层次和 “主存-辅存” 层次。

## 1. 程序访问的局部性原理

程序访问的局部性原理包括时间局部性和空间局部性。前者是指在最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序存在循环。后者是指在最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组、表等形式簇聚在一起的。

高速缓冲技术就是利用程序访问的局部性原理，把程序中正在使用的部分存放在一个高速的、容量较小的 Cache 中，使 CPU 的访存操作大多数针对 Cache 进行，从而大大提高程序的执行速度。

## 2. Cache 的基本工作原理

Cache 位于存储器层次结构的顶层，通常由 SRAM 构成。

Cache 和主存都被分成若干大小相等的块（Cache 块又称 Cache 行），每块由若干字节组成，块的长度称为块长（Cache 行长）。由于 Cache 的容量远小于主存的容量，所以 Cache 中的块数要远少于主存中的块数，它仅保存主存中最活跃的若干块的**副本**。故 Cache 按照某种策略，预测 CPU 在未来一段时间内欲访存的数据，将其装入 Cache。

当 CPU 发出读请求时，若访存地址在 Cache 中命中，就将此地址转换为 Cache 地址，直接对 Cache 进行读操作，与主存无关；若 Cache 不命中，则仍需访问主存，并把此字所在的块一次性地从主存调入 Cache。若此时 Cache 已满，则需根据某种替换算法，用这个块替换 Cache 中原来的某块信息。值得注意的是，CPU 与 Cache 之间的数据交换以字为单位，而 Cache 与主存之间的数据交换则以 Cache 块为单位。

```markdown
某些计算机中也采用同时访问 Cache 和主存的方式，若 Cache 命中，则主存访问终止；否则访问主存
并替换 Cache
```

当 CPU 发出写请求时，若 Cache 命中，有可能会遇到 Cache 与主存中的内容不一致的问题。例如，由于 CPU 写 Cache，把 Cache 某单元中的内容从 `X` 修改成了 `X‘`，而主存对应单元中的内容仍然是 `X`，没有改变。所以若 Cache 命中，需要按照一定的写策略处理，常见的处理方法有全写法和写回法，详见下面的 Cache 写策略部分。

CPU 欲访问的信息已在 Cache 中的比例称为 Cache 的命中率。设一个程序执行期间，Cache 的总命中次数为 `Nc` ，访问主存的总次数为 `Nm` ，则命中率 H 为

```markdown
H = Nc/(Nc+Nm)
```

可见提高访问效率，命中率 H 越接近 1 越好。设 `tc` 为命中时的 Cache 访问时间，`tm` 为未命中时的访问时间，`1-H` 表示未命中率，则 Cache-主存系统的平均访问时间 `Ta` 为

```markdown
Ta = H·tc + (1-H)·tm
```

例子：假设 Cache 的速度是主存的 5 倍，且 Cache 的命中率为 95%，则采用 Cache 后，存储器性能提高多少（设 Cache 和主存同时被访问，若 Cache 命中则中断访问主存）？

```markdown
设 Cache 的存储周期为 t，主存的存取周期为 5t，由 H=95% 得系统的平均访问时间为
Ta = 0.95t + 0.05×5t = 1.2t
可知性能为原来的 5t/1.2t ≈ 4.17 倍，即提高了 3.17 倍。
```

思考：若采用先访问 Cache 再访问主存的方式，则提高的性能又是多少？

```markdown
Ta = tc + (1-H)·tm
```

## 3. Cache 和主存的映射方式

在 Cache 中，地址映射是指把主存地址空间映射到 Cache 地址空间，即把存放在主存中的程序按照某种规则装入 Cache。

由于 Cache 块数比主存块数少得多，因此主存中只有一部分块的内容可放在 Cache 中，故在 Cache 中要为每个块加一个标记，指明它是主存中哪一块的副本。该标记的内容相当于主存中块的编号。为了说明标记是否有效，每个标记至少还应设置一个有效位，该位为 1 时，表示 Cache 映射的主存块数据有效，否则无效。

地址映射不同于地址变换。**地址变换是指** CPU 在访存时，将主存地址按照映射规则换算成 Cache 地址的过程。地址映射的方法有以下 3 中。

### 3.1 直接映射

主存数据块只能装入 Cache 中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无须使用替换算法）。直接映射实现简单，但不够灵活，即使 Cache 存储器的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。

直接映射的关系可定义为 

```markdown
j = i mod 2^C
```

式中，`j` 是 Cache 的块号（又称 Cache 行号），`i` 是主存的块号，`2^C` 是 Cache 中的总块数。在这种映射方式中，主存的第  0 块、第 `2^C` 块、第 `2^(C+1)` 块...... 只能映射到 Cache 的第 0 行；而主存的第 1 块、第 `2^C+1` 块、第 `2^(C+1)+1` 块..... 只能映射到 Cache 的第 1 行，以此类推。

直接映射的地址结构为：主存字块 + Cache 字块地址 + 字块内地址 。

```markdown
例如主存地址为 10010100，Cache 有 8 块，每块有 8 个字，Cache 容量为 64 字，所以主存地址结构为
    10 010 100
若是命中，10 表示主存块号，010 表示在第 2 个 Cache 行，100 在行内的第 6 个字。 
```

### 3.2 全相联映射

可以把主存数据块装入 Cache 中的任何位置。全相联映射方式的优点是比较灵活，Cache 块的冲突概率低，空间利用率高，命中率也高；缺点是地址变换速度慢，实现成本高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射。

全相联的地址结构为：主存字块标记 + 字块内地址

### 3.3 组相联映射

将 Cache 空间分成大小相同的组，主存的一个数据块可以装入一组内的任何一个位置，即组间采取直接映射，而组内采取全相联映射。它是对直接映射和全相联映射的一种折中，当 Q=1 时变为全相联映射，当 Q=Cache 块数时变为直接映射。

组相联映射的关系可以定义为 

```matlab
j = i mod Q
```

式中，`j` 是缓存的组号，`i` 是主存的块号，Q 是 Cache 组数。

组相联映射的地址结构为：主存字块标记 + 组地址 + 字块内地址。

```markdown
假设某个计算机的主存地址空间大小为 256MB，按字节编址，其数据 Cache 有 8 个 Cache 行，行长为 64B

1. 若不考虑用于 Cache 的一致维护性和替换算法控制位，并且采用直接映射方式，则该数据 Cache 的总容量为多少？
2. 若该 Cache 采用直接映射方式，则主存地址为 3200（十进制）的主存块对应的 Cache 行号是多少？
   采用二路组相联映射时又是多少？
3. 以直接映射方式为例，简述访存过程（设访存的地址为 0123456H）

解：
1. 数据 Cache 的总容量为 4256 位。
   因为 Cache 包括了可以对 Cache 中所包含的存储器地址进行跟踪的硬件，
   即 Cache 的总容量包括：存储容量、标记阵列容量（有效位、标记位）（标记阵列中的一致性维护位
   和 Cache 数据一致性维护方式有关，替换算法控制位和替换算法有关，这里不计算）
   
   注意：每个 Cache 行对应一个标记位（包括有效位、标记位 Tag、一致性维护位、替换算法控制位），而在组相联
   中，将每组的标记项排成一行，将各组从上到下排列，称为一个二维的标记阵列（直接映射一行就是一组）。查找
   Cache 时就是查找标记阵列的标记项是否符合要求。
   
   Cache 对应一个标记项，标记项 = 有效位 + 脏位 + 替换控制位 + 标记位
   
   其中标记字段长度的计算：主存地址有 28 位（256MB = 2^28 B），其中 6 位为块地址（2^6B=64B），
   3 位为行号（2^3=8），剩余 28-6-3=19 位为标记字段。
   
   所以总容量为 8×(1+19+512)=4296 位。
   
2. 直接映射方式中，主存按照块的大小划分，主存地址 3200 对应的字块号为 3200B/64B=50。
   而 Cache 只有 8 行，则 50 mod 8 = 2，故对应的 Cache 行号为 2。
   
   二路组相联映射方式，实质上就是将两个 Cache 行合并，内部采用全相联方式，外部采用直接映射方式，
   50 mod 4 = 2，对应的组号为 2，即对应的 Cache 行号为 4 或 5。
   
3. 直接映射方式中，28 为主存地址可分为 19 位的主存标记位，3 位块号，6 位的块内地址，即 
   0000 0001 0010 0011 010 为主存标记位，001 为块号，010110 为块内地址。
   首先根据块号，查 Cache (即 001 号 Cache 行) 中对应的主存标记位，看是否相同。
   
   若相同，再看 Cache 行中的装入有效位是否为 1，若是，则表示有效，称此访问命中，按块内地址
   010110 读出 Cache 行对应的单元并送入 CPU 中，完成访存。
   
   若出现标记位不相等或有效位为 0 的情况，则不命中，访问主存将数据取出并送往 CPU 和 Cache 的对应块中，
   把主存的最高 19 位存入 001 行的 Tag 中，并将有效位置 1。
   
思考：
1. 若第 1 问中采用二路组相联，则 Cache 总容量是多少？
   组地址比直接映射的 Cache 字块地址少 1 位，在标记阵列补上，所以总容量比直接映射多 8b(每行多一位)。
2. 仔细分析主存划分和 Cache 划分的关系，自行推导二路组相联映射方式的主存地址划分和访存过程。
   组相联：  主存地址 = 主存字块标记 + 组地址 + 字块内地址
   1. 求出序号，找到对应组号
   2. 顺序查找是否有主存字块标记号
   3. 若有看有效位
```

## 4. Cache 中主存块的替换算法

在采用全相联映射和组相联映射方式时，从主存向 Cache 传送一个新块，当 Cache 中的空间已被占满时，就需要使用替换算法置换 Cache 行。而采用直接映射时，一个给定的主存块只能放到一个唯一的固定 Cache 中，所以在对应 Cache 行已有一个主存块的情况下，新的主存块毫无选择地把原先已有的那个主存块替换掉，因而无须考虑替换算法。

常用的替换算法有随机（RAND）算法、先进先出（FIFO）算法、近期最少使用（LRU）算法和最不经常使用（LFU）算法。

1. 随机算法：随机地确定替换的 Cache 块。它的实现比较简单，但未依据程序访问的局部性原理，故可能命中率较低。

2. 先进先出算法：选择最早调入的行进行替换。它比较容易实现，但也未依据程序访问的局部性原理，可能会把一些需要经常使用的程序块（如循环程序）作为最早进入 Cache 的块替换掉。

3. 近期最少使用（LRU）算法：依据程序访问的局部性原理选择近期内长久未访问过的存储行作为替换的行，平均命中率要比 FIFO 高，是堆栈类算法。

   LRU 算法对每行设置一个计数器，Cache 每命中一次，命中行计数器清 0，而其他各行计数器均加 1，需要替换时比较各特定行的计数值，将计数值最大的行换出。

4. 最不经常使用算法：将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从 0 开始计数，每访问一次，被访问的行计数器加 1，需要替换时比较各特定行的计数值，将计数值最小的行换出。

## 5. Cache 写策略

因为 Cache 中的内容是主存块副本，当对 Cache 中的内容进行更新时，就需选用写操作策略使 Cache 内容和主存内容保持一致。此时分两种情况。

对于 Cache 写命中（write hit），有两种处理方法。

1. 全写法（写直通法、write-through）。当 CPU 对 Cache 写命中时，必须把数据同时写入 Cache 和主存。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。这种方法实现简单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了 Cache 的效率。写缓冲：为减少全写法直接写入主存的时间损耗，在 Cache 和主存之间加一个写缓冲（Write Buffer）。CPU 同时写数据到 Cache 和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个 FIFO 队列，写缓冲可以解决速度不匹配的问题，但若出现频繁写时，会使写缓冲饱和溢出。
2. 写回法（write-back）。当 CPU 对 Cache 写命中时，只修改 Cache 的内容，而不立即写入主存，只有当此块被换出时才写回主存。这种方法减少了访存次数，但存在不一致的隐患。采用这种策略时，每个 Cache 行必须设置一个标志位（脏位），以反映此块是否被 CPU 修改过。

全写法和写回法都对应于 Cache 写命中（要被修改的单元在 Cache 中）时的情况。

对于 Cache 写不命中，也有两种处理方法。

1. 写分配法（write-allocate）。加载主存中的块到 Cache 中，然后更新这个 Cache 块。它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块。
2. 非写分配法（non-write-allocate）。只写入内容，不进行调块。

非写分配法通常与全写法合用，写分配法通常和写回法合用。

现代计算机的 Cache 通常设立多级 Cache（通常为 3 级），假定设 3 级 Cache，按离 CPU 的远近可各自命名为 L1 Cache、L2 Cache、L3 Cache，离 CPU 越远，访问速度越慢，容量越大。指令 Cache 与数据 Cache 分离一般在 L1 级，此时通常为写分配法与写回法合用。

写回法和全写法的区别主要看是否有写缓冲。

## 6. 习题

1. 某计算机的 Cache 共有 16 块，采用二路组相联映射方式（即每组 2 块）。每个主存块大小为 32 B，按字节编址，主存 129 号单元所在主存块应装入的 Cache 组号是？
2. Cache 的更新策略
3. Tag 标记的计算
4. 主存地址的单位是什么？
5. Cache 起始字块为第 0 字块，那么 100 是第几字块？
6. `a[k] = a[k] + 32` 这条语句需要访存几次？
7. 在由高速缓冲、主存、硬盘构成的三级存储体系中，CPU 访问该存储系统时发送的地址为？
8. 块、页、帧
9. 指令 Cache 和数据 Cache 分离的主要目的是？
10. 注意 b 和 B 的单位转化 
11. 计算对应行号的时候要注意什么？
12. CPU 执行时间
13. 给出块号，如何求组号和组标记
14. 为啥缺页开销大
15. 为啥修改页面采用写回策略

## 7. 习题答案

1. 4。按字节编址，所以单元是字节。主存块和 Cache 块是对应的，所以 Cache 块也是 32B，129 = 32 + 32 + 32 + 32 + 1，所以是在第五块，从 0 编号，所以组号是 4。
2. 在写不命中时，加载相应的第一层中的块到高速缓存（Cache）中，然后更新这个高速缓存块，称为写分配法；而避开 Cache，直接把这个字写到主存中，则称为非写分配法。这两种方法都是在不命中 Cache 的情况下使用的，而写回法和全写法是在命中 Cache 的情况下使用的。在写 Cache 时，写分配法和写回法搭配使用，非写分配法和全写法搭配使用。
3. 主存地址 = Tag + 组数 + 块的大小（组数为 0 是全相联，组数为块数是直接映射）
4. 如果说按字节编码，那么单位就是字节；如果说按字编码，那么单位就是字。如果啥也没说，那么两个都试一试，有答案的就是对的。
5. 第 6 字块，千万不要减 1 ，大哥，求你了
6. 两次。读出 `a[k]` 需要访存一次，写入更新的 `a[k]` 一次，在 Cache 命中率计算中要考虑。
7. 主存物理地址。如果说是虚拟存储系统，那么就是逻辑地址。
8. 块是指 Cache 块和主存块，页是指主存页，帧是指物理帧，页和帧大小一致，只是帧在实现虚拟存储器时用到的说法。
9. 指令执行过程取指和取数据都有可能访问 Cache，这一特性保证不同的指令可以同时访存，也就是减少指令流水线资源冲突。
10. 当要计算容量时，最好通通先化为 b 或 B。
11. 开始地址（也就是偏移量）；编码方式（地址单位）
12. CPU 执行时间 = 指令数 ×（CPI + Cache 不命中率 × 不命中开销）
13. 将块号二进制化，切分成→标记号 + 组号，就搞定了
14. 读磁盘慢
15. 写磁盘慢

