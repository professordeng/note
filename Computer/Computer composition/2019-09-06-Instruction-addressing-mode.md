---
title: 4.2 指令寻址方式
date: 2019-11-20
---

寻址方式是指寻找指令或操作数有效地址的方式，即确定本指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为**指令寻址**和**数据寻址**两大类。

指令中的地址码字段并不代表操作数的真实地址，这种地址称为**形式地址**（A）。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为**有效地址**（EA）。

注意，（A）表示地址为 A 的数值，A 即可以是寄存器编号，也可以是内存地址。对应的（A）就是寄存器中的数值，或相应内存单元的数值。例如，`EA=(A)` 意思是有效地址是地址 A 中的数值。

## 1. 指令寻址和数据寻址

寻址方式分为指令寻址和数据寻址两大类。**寻找下一条将要执行的指令地址**称为指令寻址；**寻找操作数的地址**称为数据寻址。

### 1.1 指令寻址

指令寻址方式有两种：一种是顺序寻址方式，另一种是跳跃寻址方式。

1. 顺序寻址可通过程序计数器（PC）加 1（1 个指令字长），自动形成下一条指令的地址。
2. 跳跃寻址通过转移类指令实现。所谓跳跃，是指下条指令的地址码不由程序计数器给出，而由本条指令给出下条指令地址的计算方式。注意，是否跳跃可能受到状态寄存器和操作数的控制，而跳跃到的地址分为绝对地址（由标记符直接得到）和相对地址（相对于当前指令地址的偏移量），跳跃的结果是当前指令修改 PC 值，所以下一条指令仍然通过程序计数器（PC）给出。

### 1.2 数据寻址

数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址。

数据寻址的方式较多，为区别各种方式，通常在指令字中设一个字段，用来指明属于哪种寻址方式，由此可得指令的格式如下所示：

```markdown
操作码  寻址特征  形式地址A
```

## 2. 常见的数据寻址方式

### 2.1 隐含寻址

这种类型的指令不明显地给出操作数的地址，而在指令中隐含操作数的地址。例如，单地址的指令格式就不明显地在地址字段中指出第二操作数的地址，而规定累加器（ACC）作为第二个操作数地址，指令格式明显指出的仅是第一操作数的地址。因此，累加器（ACC）对单地址指令格式来说是隐含寻址。（P158）

```markdown
ADD 寻址特征 A 
```

隐含寻址的优点是有利于缩短指令字长；缺点是需增加存储操作数或隐含地址的硬件。

### 2.2 立即（数）寻址

这种类型的指令的地址字段指出的不是操作数的地址，而是操作数本身，又称立即数。数据采用补码形式存放。

```markdown
OP 立即寻址特征# A
```

`#` 表示立即寻址特征，A 就是操作数本身。

立即数寻址的优点是指令在执行阶段不访问主存，指令执行时间最短；缺点是 A 的位数限制了立即数的范围。

### 2.3 直接寻址

指令字中的**形式地址 A 是操作数的真实地址 EA**，即 `EA=A` 。

直接寻址的优点是简单，指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址；缺点是 A 的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。

### 2.4 间接寻址

间接寻址是相对于直接寻址而言的，指令的地址字段给出的形式地址不是操作数的真正地址，而是**操作数有效地址所在的存储单元的地址**，也就是**操作数地址的地址**，即 `EA=(A)` ，间接寻址可以是一次间接寻址，还可以是多次间接寻址。

主存字第一位为 1 时，表示取出的仍不是操作数的地址，即多次间址；主存字第一位为 0 时，表示取得的是操作数的地址。

间接寻址的优点是可扩大寻址范围（有效地址 EA 的位数大于形式地址 A 的位数），便于编制程序（用间接寻址可方便地完成子程序返回）；缺点是指令在执行阶段要多次访存（**一次间址需两次访存**，多次寻址需根据存储字的最高位确定几次访存）。由于访问速度过慢，**这种寻址方式并不常用**。**一般问到扩大寻址范围时，通常指的是寄存器间接寻址**。

### 2.5 寄存器寻址

寄存器寻址是指指令字中直接给出操作数所在的寄存器编号，即 `EA=Ri` ，其操作数在由 `Ri` 所指的寄存器内。寄存器寻址的优点是指令在执行阶段不访问主存，只访问寄存器，因寄存器数量较少，对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，支持向量/矩阵运算；缺点是寄存器价格昂贵，计算机中的寄存器个数有限。

### 2.6 寄存器间接寻址

寄存器间接寻址是指在寄存器 `Ri` 中给出的不是一个操作数，而是操作数所在主存单元的地址，即 `EA=(Ri)` 。

寄存器间接寻址的特点是，与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）。

### 2.7 相对寻址

相对寻址是把程序计数器（PC）的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，即 `EA=(PC)+A` ，其中 A 是相对于当前指令地址的位移量，可正可负，补码表示。（P160）

相对寻址的优点是操作数的地址不是固定的，它随 PC 值的变化而变化，且与指令地址之间总是相差一个固定值，因此便于程序浮动。相对寻址广泛应用于转移指令。

注意，对于转移指令 `JMP A` ，当 CPU 从存储器中取出一个字节时，会自动执行 `(PC)+1→PC` 。若转移指令的地址为 X，且占 2B，在取出该指令后，PC 的值会增 2，即 `(PC)=X+2` ，这样在执行完该指令后，会自动跳转到 `X+2+A` 的地址继续执行。 

### 2.8 基址寻址

基址寻址是指将 CPU 中基址寄存器（BR）的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，即 `EA=(BR)+A` 。其中基址寄存器既可采用专用寄存器，又可采用通用寄存器。

```assembly
OP X   A ; 专用寄存器
OP X R A ; R 为通用寄存器
```

基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要用于**解决程序逻辑空间与存储器物理空间的无关性**。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。

基址寻址的优点是可扩大寻址范围（基址寄存器的位数大于形式地址 A 的位数）；用户不必考虑自己的程序存于主存的哪个空间区域，故有利于多道程序设计，并可用于编制浮动程序，但偏移量（形式地址 A）的位数较短。

### 2.9 变址寻址

变址寻址是指有效地址 EA 等于指令字中的形式地址 A 与变址寄存器 IX 的内容之和。即 `EA=(IX)+A` ，其中 IX 为变址寄存器（专用），也可用通用寄存器作为变址寄存器。

变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址 A 不变（作为基地址）。

变址寻址的优点是可扩大寻址范围（变址寄存器的位数大于形式地址 A 的位数）；在数组处理过程中，可设定 A 为数组的首地址，不断改变变址寄存器 IX 的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。偏移量（变址寄存器 IX）的位数足以表示整个存储空间。

显然，**变址寻址与基址寻址的有效地址形成过程极为相似**。但从本质上讲，两者有较大区别。基址寻址面向系统，主要用于为多道程序或数据分配存储空间，故基址寄存器的内容通常由操作系统或管理程序确定，在程序执行过程中其值不可变，而指令字中的 A 是可变的；变址寻址立足于用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值可变，而指令字中的 A 是不可变的。

### 2.10 堆栈寻址

堆栈是存储器（或专用寄存器组）中一块特定的，按后进先出（LIFO）原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。堆栈可分为**硬堆栈**与**软堆栈**两种。

**寄存器堆栈**又称硬堆栈。寄存器堆栈的成本较高，不适合做大容量的堆栈；而从主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为**软堆栈**。

在采用堆栈结构的计算机系统中，大部分指令表面上都表现为无操作数指令的形式，因为操作数都隐含使用了 SP。通常情况下，在读/写堆栈中的一个单元的前后都伴有自动完成对 SP 内容的增量或减量操作。

下面简单总结寻址方式、有效地址及访存次数（不包含为了取本条指令而做的访存）

| 寻址方式           | 有效地址     | 访存次数 | 说明                                     |
| ------------------ | ------------ | -------- | ---------------------------------------- |
| 隐含寻址           | 程序指定     | 0        | 操作数在堆栈                             |
| 立即寻址           | A 即是操作数 | 0        | 多用于赋初值                             |
| 直接寻址           | EA = A       | 1        | 用于低地址                               |
| 一次间接寻址       | EA=(A)       | 2        | 操作数地址在主存                         |
| 寄存器寻址         | EA=Ri        | 0        | 操作数在寄存器中                         |
| 寄存器间接一次寻址 | EA=(Ri)      | 1        | 操作数地址在寄存器中                     |
| 相对寻址           | EA=(PC)+A    | 1        | 循环指令                                 |
| 基址寻址           | EA=(BR)+A    | 1        | 程序浮动，由操作系统控制 BR              |
| 变址寻址           | EA=(IX)+A    | 1        | 数组偏移，这里 A 是基址，由程序员控制 IX |

## 3. 习题

1. 采用不同寻址方式的目的
2. 简化地址结构的基本方法是尽量采用
3. 变址间址寻址方式是
4. 相对寻址中，指令所提供的相对地址实质上是
5. 条件转移指令的转移条件（无符号整数比较大小）
6. 对按字寻址的机器，程序计数器和指令寄存器的位数各取决于
7. 寄存器寻址和寄存器间接寻址的寄存器中分别存啥
8. 常见的单字双地址指令格式
9. 通用寄存器是啥？如何使用？数量有何限制？
10. 相对转移指令的计算

## 4. 习题答案

1. 可缩短指令字长，扩大寻址空间，提高编程的灵活性。但这会增加指令译码难度。

   实现程序控制是由程序控制指令实现的，请不要混淆。

2. 隐地址；也就是零地址指令。

3. ((X)+A)

4. 以下一条指令在内存中首地址为基准位置的偏移量。

5. 若 A>B，则 A-B 肯定无进位/借位，也不为 0（为 0 时表示两数相同），故 CF 和 ZF 均为 0 。注意不会用到符号位 SF 和溢出标志 OF。

6. 机器按字寻址，程序计数器（PC）给出下一条指令字的访存地址（指令在内存中的地址），故取决于存储器的字数；指令寄存器（IR）用于接收取得的指令，故取决于指令字长。

7. 分别存操作数的内容和操作数的有效地址。

8. OP + Ms + Rs + Md + Rd

   OP 是操作码、Ms/Md 是寻址方式，Rs 是源操作数，Rd 是目的操作数。

9. 可以用指令访问，并无特殊功能的寄存器，通用寄存器有自己的编码，而指令中限制了位数，所以通用寄存器是有限的，例如指令用 3 位标识一个通用寄存器，那么寄存器的编号是 0~7。

10. 首先判断取出指令后 PC 移动的位数，然后判断偏移量的位数。PC = (PC) + 1×k + OFFSET×k，这里的 k 是指令的长度和编码单位的比值！！（P167-Q7）

