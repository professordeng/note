---
title: 3.7 虚拟存储器
date: 2019-11-17
---

主存和联机工作的辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于应用程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量，提高了存储系统的性价比。

## 1. 虚拟存储器的基本概念

虚拟存储器将主存或辅存的地址空间统一编址，形成一个庞大的地址空间，在这个空间内，用户可以自由编程，而不必在乎实际的主存容量和程序在主存中实际的存放位置。

**用户编程允许涉及的地址称为虚地址或逻辑地址**，虚地址对应的存储空间称为虚拟空间或程序空间。实际的主存单元地址称为实地址或物理地址，实地址对应的是主存地址空间，也称实地址空间。虚地址比实地址要大得多。

```markdown
实地址 = 主存页号 + 页内字地址
虚地址 = 虚存页号 + 页内字地址
辅存地址 = 磁盘号 + 盘面号 + 磁道号 + 扇区号
```

CPU 使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元内容是否已装入主存。若已在主存中，则通过地址变换，CPU 可直接访问主存指示的实际单元；若不在主存中，则把包含这个字的一页或一段调入主存后再由 CPU 访问。若主存已满，则采用替换算法置换主存中的一页或一段。

在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前运行所需要的部分调入主存，供 CPU 使用，其余暂不运行的部分则留在磁盘中。

## 2. 页式虚拟存储器

以页为基本单位的虚拟存储器称为页式虚拟存储器。虚拟空间与主存空间都被划分成同样大小的页，主存的页称为实页，虚存的页称为虚页。把虚拟地址分为两个字段：虚页号和页内地址。虚地址到实地址之间的变换是由页表来实现的。**页表是一张存放在主存中的虚页号和实页号的对照表**，它记录程序的虚页调入主存时被安排在主存的位置。页表一般长久地保持在内存中。

页表基址寄存器存放当前运行程序的页表的起始地址，它和虚页号拼接成页表项地址，每个**页表项记录与某个虚页对应的虚页号、实页号和装入位等信息**。装入位为 1 ，表示该页面已在主存中，将对应的实页号和虚地址中的页内地址拼接，得到完整的实地址；装入位为 0 ，表示该页面不在主存中，此时要启动 I/O 系统，把该页从辅存调入主存后再供 CPU 使用。

CPU 访存时，先要查找页表，为此需要访问一次主存。不命中时，还要进行页面替换和页表修改，因此访问主存的次数就更多了。（P137）

页式虚拟存储器的优点是，页面的长度固定，页表简单，调入方便。缺点是，由于程序不可能正好是页面的整数倍，最后一页的零头将无法利用而造成浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。

## 3. 段式虚拟存储器

段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。把虚拟地址分为两部分：段号和段内地址。虚拟地址到实地址之间的变换是由段表来实现的。段表是程序的逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。

CPU 根据虚拟地址访存时，首先根据段号与段表起始地址拼接成对应的段表行，然后根据该段表行的装入位判断该段是否已调入主存（装入位为 1 ，表示该段已调入主存；装入位为 0 ，表示该段不在主存中）。已调入主存时，从段表读出该段在主存中的起始地址，与段内地址（偏移量）相加，得到对应的主存实地址。（P138）

段式虚拟存储器的优点是，段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享；缺点是因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。

## 4. 段页式虚拟存储器

把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存储器。在段页式虚拟存储器中，每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。

虚地址分为段号、段内页号、页内地址三部分。CPU 根据虚地址访存时，首先根据段号得到段表地址；然后从段表中取得该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最后从页表中取出实页号，与页内地址拼接形成主存实地址。

段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。缺点是在地址变换过程中需要两次查表，系统开销较大。

## 5. 快表（TLB）

在虚拟存储器中，必须先访问一次主存去查页表，再访问主存才能取得数据，相当于访存速度降低了一半。而在段页式虚拟存储器中，既要查找段表又要查找页表。

依据程序执行的局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的页表项存放在高速缓冲器组成的块表（TLB）中，则可以明显提高效率。相应地把放在主存中的页表称为慢表（Page）。块表只是慢表的一个副本，而且只存放了慢表中很少的一部分。

查找时，快表和慢表同时进行，**快表由于根据内容指定地址，一般使用相联存储器**。若快表中有此逻辑页号，则能很快地找到对应的物理页号，送入实主存地址寄存器，并使慢表的查找作废，从而就能做到虽采用虚拟存储器但访问主存速度几乎没有下降。

```markdown
TLB 只是 Page 的一个很小的副本，所以若 TLB 命中则 Page 一定命中
```

在同时具有虚拟页式存储器（有 TLB）和 Cache 的系统中，访问顺序为 TLB→页表→Cache→主存。CPU 发出访存命令（逻辑地址），先查找 TLB 和 Page，将逻辑地址转换为物理地址，再查找对应的 Cache 块（与主存查找并行）。若 Cache 命中，则说明所需页面已调入主存，Page 必然命中，但 TLB 不一定命中；若 Cache 不命中，则并不能说明所需页面未调入主存，和 TLB 和 Page 命中与否没有联系。若 Page 不命中，则说明所需页面未调入主存，当然 Cache 和主存也不会命中，需要执行调页策略。

## 6. 虚拟存储器与 Cache 的比较

虚拟存储器与 cache 既有很多相同之处，又有很多不同之处。

### 6.1 相同之处

1. 最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。
2. 都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大。
3. 都有地址的映射、替换算法、更新策略等问题。
4. 根据程序访问的局部性原则应用 “快速缓存的思想”，将相对活跃的数据放在相对高速的部件中。

### 6.2 不同之处

1. Cache 主要解决系统速度，而虚拟存储器却是为了解决主存容量。
2. Cache 全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由 OS 和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。
3. 对于不命中性能影响，因为 CPU 的速度约为 Cache 的 10 倍，主存的速度为硬盘的 100 倍以上，故虚拟存储器系统不命中时对系统的性能影响更大。
4. CPU 与 Cache 和主存都建立了直接访问的通路，而辅存与 CPU 没有直接通路。也就是说在 Cache 不命中时主存能和 CPU 直接通信，同时将数据调入 Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和 CPU 通信。

## 7. 习题

1. TLB 一般都是全相联，格式如何？
2. 页式和段页式采用什么方式存储？
3. 局部性原理的内涵？
4. 页表、TLB 注意事项
5. Cache 有效位的作用
6. LRU 位的个数 k 和 N 路相联的关系。

## 8. 习题答案

1. 全相联直接按内容寻找，其内容 = 虚拟地址的虚页号 + 页框号，如果有虚页号，说明在数据在 Cache 中或主存中，先去 Cache 找，没有的话再去主存找。

2. 页式

3. 程序执行存在循环，最近执行过的之后一段时间可能又用到，这是时间局部性；

   程序按照顺序执行，下一个要用到的数据很可能是现在的数据的附加，这是空间局部性。

   局部性导致程序访问主存不均匀，有些部分常用，有些部分不常用。

4. 题目常用 16 进制数，请习惯转换。

5. 指出所在行中的信息是否有效

6. 2^k=N