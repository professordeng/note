---
title: 2. 数据的表示与运算
date: 2019-11-05
---

## 1. 小结

1. 在计算机中，为什么要采用二进制来表示数据？

   从可行性来说，采用二进制，只有 0 和 1 两个状态，能够表示 0、1 两种状态的电子器件很多，如开关的接通和断开、晶体管的导通和截止、磁元件的正负剩磁、电位电平的高与低等，都可表示 0、1 两个数码。使用二进制，电子器件具有实现的可行性。

   从运算的简易性来说，二进制数的运算法则少，运算简单，使计算机运算器的硬件结构大大简化（十进制的乘法九九口诀表有 55 条公式，而二进制乘法只有 4 条规则）。

   从逻辑上来说，由于二进制 0 和 1 正好和逻辑代数的假（false）和真（true）相对应，有逻辑代数的理论基础，用二进制表示二值逻辑很自然。

2. 计算机在字长足够的情況下能够精确地表示每个数吗？若不能，请举例。

   计算机采用二进制来表示数据，在字长足够时，可以表示任何一个整数。而二进制表示小数时只能够用 1/(2^n) 的和的任意组合表示，即使字长很长，也不可能精确表示出所有小数，只能无限逼近。例如 0.1 就无法用二进制精确地表示。

3. 字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？

   字长相同时，浮点数取字长的一部分作为阶码，所以表示范围比定点数要大，而取一部分作为阶码也就代表着尾数部位的有效位数减少，而定点数字长的全部位都用来表示数值本身，精度要比同字长的浮点数更大。

4. 用移码表示浮点数的阶码有什么好处？

   移码的两个好处：

   1. 浮点数进行加减运算时，时常要比较阶码的大小，相对于原码和补码，移码比较大小更方使。
   2. 检验移码的特殊值（0 和 max）时比较容易。阶码以移码编码时的持殊值如下。0：表示指数为负无穷大，相当于分数分母无穷大，整个数无穷接近 0，在尾数也为 0 时可用来表示 0；尾数不为零表示未正规化的数。max：表示指数正无穷大，若尾数为 0，则表示浮点数超出表示范围（正负无穷大）；尾数不为 0，则表示浮点数运算错误。

## 2. 查缺补漏

1. 如何表示一个数值数据？计算机中的数值数据都是二进制数吗？

   在计算机内部，数值数据的表示方法有以下两大类：

   1. 直接用二进制数表示。分为无符号数和有符号数，有符号数又分为定点数表示和浮点数表示。无符号数用来表示无符号整数（如地址等信息）；定点数用来表示整数；浮点数用来表示实数。
   2. 二进制编码的十进制数，一般都采用 8421 码（也称 NBCD 码）来表示，用来表示整数。

   所以，计算机中的数值数据虽然都用二进制来编码表示，但不全是二进制数，也有用十进制数表示的。后面一章有关指令类型的内容中，就有对应的二进制加法指令和十进制加法指令。

2. 在高级语言编程中所定义的 `unsigned`、`short`、`int`、`long`、`float`、`double` 型数据是怎么表示的？什
   么称为无符号整数的 “溢出”？

   `unsigned` 型数据就是无符号整数，不考虑符号位，直接用全部二进制位对数值进行编码得到的就是无符号数，一般都用补码表示。

   `int` 型数据就是定点整数，一般用补码表示。`int` 型数据的位数与运行平台和编译器有关，一般是 32 位或 16 位。例如，真值是 -12 的 `int` 型整数，在机器内存储的机器数（假定用 32 位寄存器寄存）是1111 1111 1111 1111 1111 1111 1111 0100 。

   long 型数据和 short 型数据也都是定点整数，只是位数不同，分别是长整型和短整型数，通常用补码表示。

   float 型数据是用来表示实数的浮点数。现代计算机用 IEEE 754 标准表示浮点数，其中 32 位单精度浮点数就是 float 型，64 位双精度浮点数就是 double 型。

   需要注意的是，C 语言中的 `int` 型和 unsigned 型变量的存储方式没有区别，都按照补码的形式存储，在不溢出范国内的加减法运算也是相同的，只是 `int` 型变量的最高位代表待号位，而 unsigned 型中的最高位表示数值位，两者在 C 语言中的区别体现在输出时到底是采用 `%d` 还是采用 `%u` 。

   对于无符号定点整数来说，若寄存器位数不够，则计算机运算过程中一般保留低 n 位，舍弃高位。这样，会产生以下两种结果。

   1. 保留的低 n 位数不能正确表示运算结果。在这种情况下，意味着运算的结果超出了计算机所能表达的范围，有效数值进到了第 n+1 位，称此时发生了 “溢出” 现象。
   2. 保留的低 n 位数能正确表达计算结果，即高位的舍去并不影响其运算结果。

3. 如何判断一个浮点数是否是规格化数？

   为了使浮点数能尽量多地表示有效位数，一般要求运算结果用规格化数形式表示。规格化浮点数的尾数小数点后的第一位一定是个非零数。因此，对于原码编码的尾数来说，只要看尾数的第一位是否为 1 就行；对于补码表示的尾数，只要看符号位和尾数最高位是否相反。需要注意的是，IEEE 754 标准的浮点数尾数是用原码编码的。

4. 对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？

   不是，可表示的数据个数取决于编码所采用的位数。编码位数一定，编码出来的数据个数就是一定的。n 位编码只能表示 2^n 个数，所以对于相同位数的定点数和浮点数来说，可表示的数据个数应该一样多（有时可能由于一个值有两个或多个编码对应，编码个数会有少量差异）。
   
5. 什么是大端模式和小端模式？

   大端存储：一个字中的高位字节（Byte）放在内存中这个字区域的低地址处。小端存储：一个字中的低位字节（Byte）放在内存中这个字区域的低地址处。

   若将一个 32 位的整数 `0x12345678` 存放到一个整型变量 `int` 中，这个整型变量采用大端或小端模式在内存中的存储如下表，为简单起见，这里使用 OP0 表示一个 32 位数据的最高字节 MSB，使用 OP3 表示一个 32 位数据的最低字节 LSB。

   | 地址偏移 | 大端模式  | 小端模式  |
   | -------- | --------- | --------- |
   | 0x00     | 12（OP0） | 78（OP3） |
   | 0x01     | 34（OP1） | 56（OP2） |
   | 0x02     | 56（OP2） | 34（OP1） |
   | 0x03     | 78（OP3） | 12（OP0） |

   大端存储和小端存储的区别是字中字节的存储顺序不同，而字的存储顺序是相同的。若一个字符串或数超过了一个字长，则应将其分割之后再小端或大端存储。

   理解之后可以如此记忆：大端→高位→在前→正常的逻辑顺序和小端→低位→在前→与正常逻辑顺序相反。

6. 浮点如何进行舍入？

   舍入方法选择的原则是：

   1. 尽量使误差范围对称，使得平均误差为 0，即有舍有入，以防误差积累
   2. 方法要简单，以加快速度。

   IEEE 754 有 4 种舍入方式。

   1. 就近舍入：舍入为最近可表示的数，若结果值正好落在两个可表示数的中间，则一般选择舍入结果为偶数。
   2. 正向舍入：朝 +∞ 方向舍入，即取右边的那个数。
   3. 负向舍入：朝 -∞ 方向舍入，即取左边的那个数。
   4. 截去：朝 0 方向舍入，即取绝对值较小的那个数。

7. 现代计算机中是否要考虑原码加减运算？如何实现？

   因为现代计算机中浮点数采用 IEEE 754 标准，所以在进行两个浮点数的加减运算时，必须考虑原码的加减运算，因为 IEEE 754 规定浮点数的尾数都用原码表示。

   原码的加减运算可以有以下两种实现方式：

   1. 转换为补码后，用补码加减法实现，结果再转换为原码。
   2. 直接用原码进行加减运算，符号和数值部分分开进行。

8. 长度为 n+1 的定点数，按照不同的编码方式，表示的数值范围是多少？

   | 编码方式       | 最小值编码  | 最小值  | 最大值编码  | 最大值    | 数值范围  |
   | -------------- | ----------- | ------- | ----------- | --------- | --------- |
   | 无符号定点整数 | 0000...000  | 0       | 1111...111  | 2^(n+1)-1 | min≤x≤max |
   | 无符号定点小数 | 0.00...0000 | 0       | 0.11...111  | 1-2^-n    | min≤x≤max |
   | 原码定点整数   | 1111...111  | -2^n+1  | 0111...111  | 2^n-1     | min≤x≤max |
   | 原码定点小数   | 1.111...111 | -1+2^-n | 0.111...111 | 1-2^-n    | min≤x≤max |
   | 补码定点整数   | 1000...000  | -2^n    | 0111...111  | 2^n-1     | min≤x≤max |
   | 补码定点小数   | 1.000...000 | -1      | 0.111...111 | 1-2^-n    | min≤x≤max |
   | 反码定点整数   | 1000...000  | -2^n+1  | 0111...111  | 2^n-1     | min≤x≤max |
   | 反码定点小数   | 1.000...000 | -1+2^-n | 0.111...111 | 1-2^-n    | min≤x≤max |
   | 移码定点整数   | 0000...000  | -2^n    | 1111...111  | 2^n-1     | min≤x≤max |

   移码定点小数没有定义。

9. 设阶码和尾数均用补码表示，阶码部分共 K+1 位（含 1 位阶符），尾数部分共 n+1 位（含 1 位数符），则这样的浮点数的表示范围是多少？

   | 浮点数                 | 阶码   | 尾数      | 真值                  |
   | ---------------------- | ------ | --------- | --------------------- |
   | 最大正数               | 01...1 | 0.11...11 | (1-2^-n)×2^(2^k-1)    |
   | 绝对值最大负数         | 01...1 | 1.00...00 | -1×2^(2^k-1)          |
   | 最小正数               | 10...0 | 0.00...01 | 2^-n×2^(-2^k)         |
   | 规格化的最小正数       | 10...0 | 0.10...00 | 2^-1×2^(-2^k)         |
   | 绝对值最小负数         | 10...0 | 1.11...11 | -2^-n×2^(-2^k)        |
   | 规格化的绝对值最小负数 | 10...0 | 1.01...11 | -(2^-1+2^-n)×2^(-2^k) |

   这里注意：补码负数的规格化数一定是 1.0xxx 格式的。0.10...0 不是规格数。
