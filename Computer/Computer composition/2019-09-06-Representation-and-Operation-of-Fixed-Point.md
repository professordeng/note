---
title: 2.2 定点数的表示和运算
date: 2019-11-07
---

## 1. 定点数的表示

### 1.1 无符号数和有符号数的表示

在计算机中参与运算的机器数有两大类 ：无符号数和有符号数。

1. 无符号数。指整个机器字长的全部二进制均为数值位，没有符号位，相当于数的绝对值。若机器字长为 8 位，则数的表示范围为 0~2⁸-1 ，即 0~255。
2. 有符号数。在机器中，数的 `+`、`-` 号是无法识别的，有符号数用 0 表示 `+` 号，用 1 表示 `-` 号，从而将符号也数值化，并通常约定二进制的最高位为符号位，即将符号位放在有效数字的前面，组成有符号数。

有符号数的机器表示有原码、补码、反码和移码。为了能正确区别真值和各种机器数，约定用 X 表示真值，用 `[X]原`表示原码，`[X]补` 表示补码，`[X]反` 表示反码，`[X]移` 表示移码。

### 1.2 机器数的定点表示

根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示和浮点表示。这节仅介绍定点表示，浮点表示见 2.3 节。

定点表示即约定机器数中的小数点位置是固定不变的，小数点不再使用 `.` 表示，而是约定它的位置。理论上，小数点固定在哪一位都可以，但在计算机中通常采用两种简单的约定：将小数点的位置固定在数据的最高位之前，或固定在最低位之后。一般常称前者为定点小数，后者为定点整数。

1. 定点小数

   定点小数是纯小数，约定小数点位置在符号位之后、有效数值部分最高位之前。

   最高位为 0，其余位均为 1，X 为其所能表示的最大正数，真值等于 `1-2^(-n)`

   全部位为 1 时，X 为所能表示的最小负数，真值等于 `-(1-2^(-n))` 

2. 定点整数

   定点整数是纯整数，约定小数点位置在有效数值部分最低位之后。

   当最高位为 0，其余位均为 1 时，X 为其所能表示的最大正数，真值等于 `2^n-1`

   全部位为 1 时，X 为其（原码）所能表示的最小负数，真值等于 `-(2^n-1)` 

### 1.3 原码、补码、反码、移码

1. 原码表示法

   简单，直观。最高位表示符号，其余位表示数的绝对值 。

   - 纯小数

     ```markdown
     字长为 8 位
     x1 = +0.1101, 则原码为 0.1101000
     x2 = -0.1101, 则原码为 1-(-0.1101)=1.1101000
     ```

     原码小数的表示范围关于原点对称

   - 纯整数

     ```markdown
     字长为 8 位
     x1 = +1110，则原码为 00001110
     x2 = -1110，则原码为 10001110 
     ```

     原码整数的表示范围关于原点对称

     注：真值 0 的原码有正零和负零两种形式。

2. 补码表示法

   原码表示法的加减法操作比较复杂，对于两个不同符号数的加法（或同符号数的减法），先要比较两个数的绝对值大小，然后用绝对值大的数减去绝对值小的数，最后还要给结果选择合适的符号。而补码表示法中的加减法则统一采用加法操作实现。

   - 纯小数的补码定义

     ```markdown
     字长为 8 位
     x1 = +0.1001，则其补码为 0.1001000 
     x2 = -0.0110，则其补码为 2-0.0110 = 1.1010000
     ```

     若字长为 n+1，则补码的表示范围为 `-1≤x≤1-2^(-n)` （比原码多表示 `-1`）

   - 纯整数的补码定义

     ```markdown
     若字长为 8 位
     x1 = +1010，其补码为 00001010
     x2 = -1101，其补码为 2⁸-00001101=11110011
     ```

     若字长为 n+1 ，则补码的表示范围为 `-2^n≤2^n-1` （比原码多表示 `-2^n`）。

   注意：真值零的补码表示是唯一的。即 `[+0]补=[-0]补=0.0000` ，由定义 `[-1]补=10.0000-1.0000=1.0000` ，可见对于小数，补码比原码多表示一个 `-1` 。类似地，对于整数，补码比原码多表示一个 `-2^n` 。

   - 由原码求补码、由补码求原码

     对于正数，补码与原码的表示相同。

     对于负数，原码符号位不变，数值部分按位取反，末位加 1（即所谓 “取反加 1”），此规则同样适用于由补码求原码。

3. 反码表示法

   反码通常用来作为由原码求补码或由补码求原码的中间过渡。

   - 纯小数的反码

     ```markdown
     字长为 8 位
     x1 = +0.0110，其反码为 0.0110000
     x2 = -0.0110，其反码为 1.1111111-0.0110000=1.1110100
     ```

     若字长为 n+1，则反码的表示范围为 `-(1-2^-n)≤1-x^-n` （关于原点对称）。

     注：真值零的反码表示不唯一，负数的反码符号位为 `1` ，数值部分取反，`[+0]反=0.0000` ；`[-0]反=1.1111`

   - 纯整数的反码

     ```markdown
     字长为 8 位
     x1 = +1011，则其反码为 00001011
     x2 = -1011，则其反码为 11111111-00001011=11110100
     ```

     若字长为 n+1，则反码的表示范围为 `-(2^n-1)≤x≤2^n-1` （关于原点对称）

4. 移码表示法

   移码常用来表示浮点数的阶码。它只能表示整数。

   移码就是在真值 X 上加上一个常数（偏置值），通常这个常数取 `2^n` ，相当于 X 在数轴上向正方向偏移了若干单位，这就是 “移码” 一词的由来。移码定义为

   ```markdown
   [x]移 = 2^n + x (2^n>x≥-2^n，其中机器字节长为 n+1)
   ```

   例如，若正数 x1=+10101, x2=-10101 ，字长为 8 位，则其移码表示为 ：`[x1]移=2^7+10101=10010101` ，`[x2移]=2^7+(-10101)=01101011` 。

   移码具有以下特点：

   1. 移码中零的表示唯一，`[+0]移 = 2^n+0=[-0]移=2^n-0=100...0` （n 个 0）。
   2. 一个真值的移码和补码仅差一个符号位，`[x]补` 的符号位取反即得 `[x]移` （1 表示正，0 表示负，这与其他机器数的符号位取值正好相反，反之亦然）。
   3. 移码全 0 时，对应真值的最小值 `-2^n` ；移码全 1 时，对应真值的最大值 `2^n-1` 。
   4. 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。

## 2. 定点数的运算

### 2.1 定点数的移位运算

移位运算根据操作对象的不同分为算术移位和逻辑移位 。有符号的移位称为算术移位，逻辑移位的操作对象是逻辑代码，可视为无符号数。

1. 算术移位

   算术移位的对象是有符号数，在移位过程中符号位保持不变。

   对于正数，由于 `[x]原=[x]补=[x]反=真值` ，故移位后出现的空位均以 0 添之。对于负数，由于原码、补码、反码的表示形式不同，故当机器数移位时，对其空位的填补规则也不同。

   ```markdown
   不论是正数还是负数，移位后其符号位均不变，且移位后都相当于对真值补 0，根据补码、反码的特性，所以
   在负数时填补代码有区别。
   ```

   对于原码，左移一位若不产生溢出，相当于乘以 2（与十进制的左移一位相当于乘以 10 类似），右移一位，若不考虑因移出而舍去的末位尾数，相当于除以 2。

   |      | 码制             | 添补代码           |
   | ---- | ---------------- | ------------------ |
   | 正数 | 原码、补码、反码 | 0                  |
   | 负数 | 原码             | 0                  |
   | 负数 | 补码             | 左移添 0，右移添 1 |
   | 负数 | 反码             | 1                  |

   正数的原码、补码与反码都相同，故移位后出现的空位均以 0 添之。对于负数，由于原码、补码和反码的表示形式不同，故当机器数移位时，对其空位的添补规则也不同。

   1. 负数的原码数值部分与真值相同，故在移位时只要使符号位不变，其空位均添 0。
   2. 负数的反码各位除符号位外与负数的原码正好相反，故移位后所添的代码应与原码相反，即全部添 1。
   3. 分析由原码得到补码的过程发现，当对其低位向高位找到第一个 1 时，在此 1 左边的各位均与对应的反码相同，而在此 1 右边的各位（包括此 1 在内）均与对应的原码相同。故负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添 0；右移时因空位出现在高位，则添补的代码应与反码相同，即添 1。

2. 逻辑移位

   逻辑移位将操作数视为无符号数，移位规则：逻辑左移时，高位丢失，低位添 0；逻辑右移时，低位移丢，高位添 0 。

   注意：逻辑移位不管是左移还有右移，都添 0。

3. 循环移位

   循环移位分为带进位标志 CF 的循环移位（大循环）和不带进位标志位的循环移位（小循环）。

   循环移位的主要特点是，移出的数位又被移入数据中，而是否带进位则要看是否将进位标志位加入循环位移。带进位位的循环左移就是数据位连同进位标志位一起左移，数据的最高位移入进位标志位 CF，而进位位则依次移入数据的最低位。

   循环移位操作特别适合将数据的低字节数据和高字节数据互换。（P40）

### 2.2 原码定点数的加减法运算

加法规则：先判符号位，若相同，则绝对值相加，结果符号位不变；若不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同。

减法规则：两个原码表示的数相减，首先将减数**符号取反**，然后将被减数与符号取反后的减数按原码加法规则进行运算。

注意：运算时注意机器字长，当左边位出现溢出时，将溢出位丢掉。

### 2.3 补码定点数加减法运算

补码加减法规则简单，易于实现，因此计算机系统中普遍采用补码加减运算。补码运算的特点如下（设机器字长为 n+1）。

1. 参与运算的两个操作数均用补码表示。

2. 按二进制运算规则运算，逢二进一。

3. 符号位与数值位按同样规则一起参与运算，符号位运算产生的进位要丢掉，结果的符号位由运算得出。

4. 补码加减运算依据下面的公式进行。当参与运算的数是定点小数时，模 `M=2` ；当参加运算的数是定点整数时，模 `M=2^(n+1)` 。

   ```markdown
   [A+B]补=[A]补+[B]补  (mod M)
   [A-B]补=[A]补+[-B]补 (mod M)
   注意：mod M 运算是为了将溢出位丢掉。
   ```

5. 补码运算的结果亦为补码。

```markdown
设机器字长为 8 位(含 1 位符号位)，A=15，B=24，求 [A+B]补 和 [A-B]补
A = +15 = +0001111 ，得 [A]补 = 00001111
B = +24 = +0011000 ，得 [B]补 = 00011000 ，求得 [-B]补 = 11101000
[A+B]补 = 00001111 + 00011000 = 00100111，其符号位为 0，对应真值为 +39
[A-B]补 = [A]补 + [-B]补 = 00001111 + 11101000 = 11110111，其符号位为 1，对应真值为 -9
```

### 2.4 符号拓展

在计算机算术运算中，有时必须把采用给定位数表示的数转换成具有不同位数的某种表示形式。例如，某个程序需要将一个 8 位数与另外一个 32 位数相加，要想得到正确的结果，在将 8 位数与 32 位数相加之前，必须将 8 位数转换成 32 位数形式，这称为符号拓展。

正数的符号拓展非常简单，即原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用 0 进行填充。

负数的符号拓展方法则根据机器数的不同而不同。原码表示负数的符号拓展方法与正数相同，只不过此时符号位为 1，补码表示负数的符号拓展方法：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用 1 （对于正数）或 0（对于小数）进行填充。反码表示负数的符号拓展方法：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用 1 进行填充。

### 2.5 溢出概念和判别方法

溢出是指运算结果超过了数的表示范围。通常，称大于机器所能表示的最大正数为上溢，称小于机器所能表示的最小负数为下溢。定点小数的表示范围为 `|X|<1` 

仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，如两个正数相加，而结果的符号位却为 1（结果为负）；一个负数减去一个正数，结果的符号位却为 0（结果为正）。定点数加减运算出现溢出时，运算结果是错误的。

补码定点数加减运算溢出判断的方法有 3 种。

1. 采用一位符号位

   由于减法运算在机器中是用加法器实现的，因此无论是加法还是减法，只要参加操作的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出。设 A 的符号位为 `As`，B 的符号位为 `Bs`，运算结果的符号位为 `Ss`，则溢出逻辑表达式为

   ```markdown
   V=AsBs(Ss)杠 + (As)杠(Bs)杠Ss
   ```

   若 `V=0` ，表示无溢出；若 `V=1` ，表示有溢出。

2. 采用双符号位

   双符号位法也称模 4 补码。运算结果的两个符号位 `Ss1Ss2` 相同，表示未溢出；运算结果的两个符号位 `Ss1Ss2` 不同，表示溢出，此时最高位符号位代表真正的符号。

   符号位 `S21Ss2` 的各种情况如下：

   1. `S21Ss2=00` ：表示结果为正数，无溢出。
   2. `S21Ss2=01` ：表示结果正溢出。
   3. `S21Ss2=10` ：表示结果负溢出。
   4. `S21Ss2=11` ：表示结果为负数，无溢出。

3. 采用一位符号位根据数据位的进位情况判断溢出

   若符号位的进位 `Cs` 与最高数位的进位 `C1` 相同，则说明没有溢出，否则表示发生溢出。溢出逻辑判断表达式为 `V=Cs⊕C1` ，若 `V=0` ，表示无溢出；`V=1` ，表示有溢出。

### 2.6 定点数的乘法运算

在计算机中，乘法运算由 “累加-右移” 操作实现。根据机器数的不同，可分为原码移位乘法和补码移位乘法。原码移位乘法的规则比补码移位乘法简单。

1. 原码移位乘法

   原码移位乘法的特点是符号位与数值位是分开求的，乘积符号由两个数的符号位 "异或" 形成，而乘积的数值部分则是两个数的绝对值相乘之积。

   假设两个数的绝对值分别为 x、y，结果 z 的初始值为 0，机器数长为 n+1 位，运算如下：

   1. x 作为被乘数，若 y 的最低位为 1，z=z+x。
   2. y 右移一位（去掉当前的最低位），z 右移一位
   3. 重复 1、2 步骤 n 次。

   注意：考虑到运算时可能出现绝对值大于 1 的情况（但此刻并非溢出），所以部分积和被乘数取双符号位。

   ```markdown
   设机器字长为 5 位（含 1 位符号位，n = 4），x = -0.1101, y = +0.1011，采用原码一位乘法求 x·y
   1. 符号位 1⊕0=1
   2. |x|=00.1101, |y| = 00.1011 ，原码一位乘法的求解过程如下。
      (高位部分积)       (低位部分积/乘数)    说明  
           00.0000        1011|丢失位    起始情况
      +|x| 00.1101            |         低位部分积为 1，则 +|x|
      ------------            |
           00.1101            | 
      r    00.0110   ---- 1101|1        右移部分积和乘数 
      +|x| 00.1101            |         低位部分积为 1，则 + |x|
      ------------            |
           01.0011            | 
      r    00.1001   ---- 0110|11       右移部分积和乘数 
      +0   00.0000            |         低位部分积为 0，则 + 0
      ------------            |
           00.1001            | 
      r    00.0100   ---- 1111|011      右移部分积和乘数 
      +|x| 00.1101            |         低位部分积为 1，则 + |x|
      ------------            |
           01.0001            | 
      r    00.1000   ---- 1111|1011     右移部分积和乘数 
      乘数全部移出，计算完成，绝对值为 0.10001111
   综上所述，答案为 -0.10001111
   ```

2. 补码一位乘法（Booth 算法）

   这是一种有符号数的乘法，采用相加和相减操作计算补码数据的乘积。

   设 `[X]补=xs·x1x2...xn` 为被乘数，`[y]补=ys·y1y2...yn` 为乘数，则运算规则如下

   1. 符号位参与运算，运算的数均以补码表示。

   2. 被乘数一般取双符号位参与运算，部分积取双符号位，初值为 0，乘数可取单符号位。

   3. 乘数末位增设附加位 y_(n+1)。

   4. 根据 (y_n,y_(n+1)) 的取值来确定操作，见下表

      | y_n（高位） | y_(n+1)（低位） | 操作                        |
      | ----------- | --------------- | --------------------------- |
      | 0           | 0               | 部分积右移一位              |
      | 0           | 1               | 部分积加 `[x]补`，右移一位  |
      | 1           | 0               | 部分积加 `[-x]补`，右移一位 |
      | 1           | 1               | 部分积右移一位              |

   5. 移码按补码右移规则进行。

   6. 按照上述算法进行 n+1 步操作，但第 n+1 步不再移位（共进行 n+1 次累加和 n 次右移），仅根据 y_n 与 y_(n+1) 的比较结果做相应的运算。

   ```markdown
   设机器字长为 5 位（含 1 位符号位，n=4），x = -0.1101, y = 0.1011 , 采用 Booth 算法求 x·y
   
   [x]补 = 11.0011 ，[-x]补 = 00.1101 
   [y]补 =  0.1011 （小数点前面的表示符号位，乘数可取单符号位）
   Booth 算法求解过程如下
         (高位部分积)       (低位部分积/乘数)     说明  
              00.0000      0.1011|0 丢失位    起始情况
      +[-x]bu 00.1101            |           yn,y_(n+1)=10，+[-x]补
      ---------------            |
              00.1101            | 
        r     00.0110 ---- 10.101|10         右移部分积和乘数 
      + 0     00.0000            |           yn,y_(n+1)=11，+0
      ---------------            |
              00.0110            | 
        r     00.0011 ---- 010.10|110        右移部分积和乘数 
      +[x]bu  11.0011            |           yn,y_(n+1)=01，+[x]补
      ---------------            |
              11.0110            | 
      r       11.1011 ---- 0010.1|0110       右移部分积和乘数 
      +[-x]bu 00.1101            |           yn,y_(n+1)=10，+[-x]补
      ---------------            |
              00.1000            | 
      r       00.0100 ---- 00010.|1011       右移部分积和乘数
      +[x]bu  11.0011            |           yn,y_(n+1)=01，+[x]补
      ---------------
              11.0111
   计算完成，高位部分积和低位部分积拼接得到结果的补码 11.01110001，结果为 11.10001111。
   ```

3. 乘法运算总结

   | 乘法类型     | 符号位                                                     | 累加次数 | 移位                      |
   | ------------ | ---------------------------------------------------------- | -------- | ------------------------- |
   | 原码移位乘法 | 不参与运算，<br />部分积有两个符号位<br />乘数不需要符号位 | n        | 往右移 n 次，每次移动一位 |
   | 补码移位乘法 | 参与运算<br />部分积有两个符号位<br />乘数需要一个符号位   | n+1      | 往右移 n 次，每次移动一位 |

### 2.7 定点数的除法运算

在计算机中，除法运算可转换成 “累加-左移”（逻辑左移），根据机器数的不同，可分为原码除法和补码除法。

1. 原码除法运算（不恢复余数法）

   原码除法主要采用原码不恢复余数法，也称原码加减交替除法。特点是商符和商值是分开进行的，商符由两个操作数的符号位 “异或” 形成。求商值的规则如下。

   设被除数 `aX`，除数 `bY` （a 和 b 为符号，X 和 Y 为数值）

   1. 商的符号：c=a⊕b。
   2. 商的数值：Q=X/Y。

   求 Q 的不恢复余数法运算规则如下。

   1. 符号位不参加运算。
   2. 先用被除数减去除数（X-Y=X+(-Y)=X+(-Y)补，因为 X 肯定比 Y 大，得到的结果是正数，正数的补码和原码是一样的），当余数为正时，商上 1，余数和商左移一位，再减去除数；当余数为负时，商上 0，余数和商左移一位，再加上除数
   3. 当第 n+1 步余数为负时，需加上 Y 得到第 n+1 步正确的余数（余数与被除数同号）。

   ```markdown
   设机器字长为 5 位（含 1 位符号位，n=4），x=0.1011，y=0.1101，采用原码加减交替除法求 x/y
   
   [x]原=00.1000，[x]补=00.1000 
   [y]原=11.1011，[y]补=11.0101，[-y]补码=00.1011。
   原码不恢复余数法的求解过程如下
              被除数     商          说明
              0.1011    0.0000     起始情况
   +[-|y|]补  1.0011               -|y| 即 +[-|y|]补
   -----------------
              1.1110    0.0000     部分余数为负，商上 0
      l       1.1100----0.0000     余数和商左移一位
     +|y|     0.1101               +|y|
   ------------------
              0.1001    0.0001     部分余数为正，商上 1
      l       1.0010----0.0010     余数和商左移一位
   +[-|y|]补  1.0011               -|y| 即 +[-|y|]补
   ------------------
              1.1101    0.0110     部分余数为负，商上 0
      l       1.1010----0.1100     余数和商左移一位
   +[y]       0.1101               +|y|
   ---------------
              0.0111    0.1101     部分余数为正，商上 1
              余数       商
   故符号位为 0，得 x/y=+0.1101，余数是 0.0111×2^(-4)
   ```

2. 补码除法运算（加减交替法）

   补码一位除法的特点是，符号位与数值位一起参加运算，商符自然形成。除法第一步根据被除数和除数的符号决定是做加法还是减法；上商的原则根据余数和除数的符号位共同决定，同号上商 1，异号上商 0；最后一步商恒置 1。

   加减交替法的规则如下

   1. 符号位参加运算，除数与被除数均用补码表示，商和余数也用补码表示。
   2. 若被除数与除数同号，则被除数减去除数；若被除数与除数异号，则被除数加上除数。
   3. 若余数与除数同号，则商上 1，余数左移一位减去除数；若余数与除数异号，则商上 0，余数左移一位加上除数。
   4. 重复执行第 3 步操作 n 次
   5. 若对商的精度没有特殊要求，则一般采用 “末位恒置 1” 法。

   ```markdown
   设机器字长为 5 位（含 1 位符号位，n=4），x=0.1000，y=-0.1011，采用补码加减交替法求 x/y。
   
   采用双符号位表示：
   [x]原=00.1000，[x]补=00.1000
   [y]原=11.1011，[y]补=11.0101，[-y]补=00.1011
   补码加减交替法的求解过程如下
            被除数     商         说明
            00.1000   0.0000     起始情况
   +[y]补   11.0101              [x]补和[y]补异号，+[y]补 
   ----------------
            11.1101   0.0001     部分余数与[y]补同号，则商上 1
     l      11.1010---0.0010     左移一位
   +[-y]补  00.1011              加减交替              
   ----------------
            00.0101   0.0010     部分余数与[y]补异号，则商上 0
     l      00.1010---0.0100     左移一位
   +[y]补   11.0101              加减交替
   ----------------
            11.1111   0.0101     部分余数与[y]补同号，则商上 1
     l      11.1110---0.1010     左移一位
   +[-y]补  00.1011              加减交替
   ----------------
            00.1001   0.1010     部分余数与[y]补异号，则商加 0
     l      01.0010---1.0100     左移一位
   +[y]补   11.0101              加减交替
   ----------------
            00.0111   1.0101     末位恒置 1
            余数       商
   得到商的补码 1.0101，余数 0.0111×2^(-4) 
   ```

3. 除法运算总结

   | 乘法类型       | 符号位参与运算 | 加减次数   | 移位      | 说明                       |
   | -------------- | -------------- | ---------- | --------- | -------------------------- |
   | 原码加减交替法 | 否             | N+1 或 N+2 | 向左 N 次 | 若最终余数为负，需恢复余数 |
   | 补码加减交替法 | 是             | N+1        | 向左 N 次 | 商末位恒置 1               |

## 3. 强制类型转换

先以 C 语言中的有符号数与无符号数的转换为例进行说明。C 语言允许在不同的数据类型之间进行强制类型转换，而从数学的角度来说，可以想到很多不同的转换规则。就用户使用而言，对于两者都能表示的数，当然希望转换过程中数值本身不发生任何变化，而那些转换过后无法表示的数呢？请先观察如下这段程序：

```c
int main() {
    short x = -4321;
    unsigned short y = (unsigned short)x;
    printf("x=%d, y=%u\n", x, y);
}
```

有符号数 x 是一个负数，而无符号数 y 的表示范围显然不包括 x 的值。在采用补码的机器上，上述代码会输出如下结果：

```c
x = -4321, y = 61215
```

最后的结果中，得到的 y 值似乎与原来的 x 没有一点关系。不过将这两个数化为二进制表示时，我们会发现其中的规律。如下：

```c
变量     值      二进制表示
 x    -4321    1110 1111 0001 1111
 y    61215    1110 1111 0001 1111
```

其中 x 为补码表示，y 为无符号的二进制真值。观察可知，将 `short int` 强制转换为 `unsigned short` 只改变数值，而两个变量对应的每位都是一样的。通过这个例子就可以知道，强制类型转换的结果保证位值不变，仅改变了解释这些位的方式。

下面再来看一个 `unsigned short` 型转换到 `short` 型的例子。考虑如下代码：

 ```c
int main() {
    unsigned short x = 65535;
    short y = (short)x;
    printf("x=%u, y=%d\n", x, y);
}
 ```

同样在采用补码的机器上，上述代码会输出以下结果：

```c
x = 65535, y = -1
```

同样可以把这两个数用之前的方法写成二进制，然后证实我们之前得出的结论。

另一种常见的运算是在不同字长的正数之间进行数值转换。先观察如下程序：

```c
int main(){
    int x = 165537, u = -34991;        // int 型占用 4B
    short y = (short)x, v = (short)u;  // short 型占用 2B
    printf("x=%d, y=%d\n", x, y); 
    printf("u=%d, v=%d\n", u, v);     
}
```

这段程序可以得出如下结果：

```c
x = 165537, y = -31071
u = -34991, v = 30545
```

其中 x、y、u、v 的十六进制表示分别为  `0x000286a1` 、`0x86a1` 、`0xffff7751` 、`0x7751` ，观察上述数字很容易得出结论，当大字长变量向小字长变量强制类型转换时，系统把多余的高位字长部分直接截断，低位直接赋值，因此也是一种保持位值的处理方法。

最后来看小字长变量向大字长变量转换的情况。先观察下面这段程序：

```c
int main(){
    short x = -4321;
    int y = x;
    unsigned short u = (unsigned short)x;
    unsigned int v = u;
    printf("x=%d, y=%d\n", x, y);
    printf("u=%u, v=%v\n", u, v);
}
```

运行结果如下：

```c
x = -4321, y = -4321
u = 61215, v = 61215
```

x、y、u、v 的十六进制表示分别是 `0xef1f` 、`0xffffef1f` 、`0xef1f` 、`0x0000ef1f` ，由这个例子可知短字长变量到长字长变量的转换，不仅要使相应的位值相等，高位部分还会扩展为原数字的符号位，这与之前的三个例子都是不一样的，从位值与数值的角度说，前三个例子的转换规则都是保证相应的位值相等，而短字长到长字长的转换，在位值相等的条件下还要补充高位的符号位，可以理解为数值的相等。

## 4. 习题

1. short 按边界对齐存储具体表现？

2. `unsigned short` 隐性转换为 `unsigned int` 的表现？

3. ```c
   short si = -32757;
   unsigned short usi = si;
   ```

   则 `usi` 的值是多少？

4. 在定点运算器中，无论是采用双符号位还是采用单符号位，必须有？

5. 模 4 补码（P50-Q32）

6. 实现 N 位（不包括符号位）补码一位乘时，乘积是多少位？

7. 原码不恢复余数法的特点。

8. 补码除法的特点。

9. 给出补码，如何表示真值？，例如 8 位补码 10010000

10. 当数字很大的时候如何表示？

11. 有符号整数加减、无符号整数加减运算，这四种运算能否利用同一个加法器辅助电路实现？

12. 如何判断有符号数加减运算溢出

13. 小数 -x （x 是数值）的补码用 x 表示

## 5. 习题答案

1. 起始地址能被自身整除，short 是 2 字节，所以应该是 2 的倍数。

2. 高位直接补 0 即可。

3. 需要记住的是 2¹⁵=32768，2¹⁶=65536，计算机中的数都是以补码的形式存储的， `si` 的二进制原码表示应该是 1111 1111 1111 1111，所以补码表示是 1000 0000 0000 0001，而从 `short` 转变到 `unsigned short` 的二进制存储并不会变，只是以无符号数解释 `si`，所以 `usi` 的值是 2¹⁵+1=32769  

4. 溢出判断电路，它一般用 “异或” 门实现

5. 模 4 补码具有模 2 补码的全部优点且更易检查加减运算中的溢出问题。模 4 补码有双符号位，平时只需要存储一个符号位，在 ALU 中才拓展为双符号位。

6. 2N+1

7. 仅当最后一步不够减时，才恢复一次余数。

8. 补码除法（不恢复余数法/加减交替法），异号相除是看够不够减，然后上商，够减商 0，不够减商 1。

9. 先翻译为原码，得 11110000，将符号位提出来，得到真值：- 01110000

10. 用指数形式表示、二进制表示或者间接表示，例如（2³¹-2²）之类的。

11. 能。n 位加法器实现的是模 2^n 无符号整数加法运算。对于无符号整数 a+b。a+b 可以直接用加法器实现，而 a-b 可用 a 加 b 的补数实现，即 a-b=a+[-b]补（mod 2^n），所以 n 位无符号整数加减运算都可在 n 位加法器中实现。

    由于有符号整数用补码表示，可利用补码规律进行运算。

12. 两个操作数符号相同，得到的结果和两个操作数不同，表示溢出。

13. [-x]补 = 2+x