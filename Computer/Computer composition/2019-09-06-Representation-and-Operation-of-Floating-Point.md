---
title: 2.3 浮点数的表示与运算
date: 2019-11-08
---

## 1. 浮点数的表示

浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动。这样，在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度。例如，用定点数表示电子的质量 `9×10^(-28) g` 或太阳的质量 `2×10^23 g` 是非常不方便的。 

### 1.1 浮点数的表示格式

通常，浮点数表示为

```markdown
N = r^E × M
```

式中，r 是浮点数阶码的底（隐含），与尾数的基数相同，通常为 `r=2` 。E 和 M 都是有符号的定点数，E 称为阶码，M 称为尾数。可见浮点数由阶码和尾数两部分组成。

```markdown
浮点数的一般格式 = 阶符 + 阶码的数值部分 + 数符 + 尾数的数值部分
```

阶码是整数，阶符和阶码的位数共同反映浮点数的表示范围及小数点的实际位置；数符代表浮点数的符号；尾数的位数 n 反映浮点数的精度。

### 1.2 规格化浮点数

为了提高运算的精度，需要充分地利用尾数的有效数位，通常采取浮点数规格化形式，即规定尾数的最高数位必须是一个有效值。非规格化浮点数需要进行规格化操作才能变成格式化浮点数。所谓规格化操作，是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高数位上保证是一个有效值。

左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算术左移一位、阶码减 1（基数为 2 时）的方法称为左规，左规可能进行多次。

右规：当浮点数运算的结果尾数出现溢出（双符号位为 01 或 10）时，将尾数算术右移一位，阶码加 1（基数为 2 时）的方法称为右规。需要右规时，只需进行一次。

规格化浮点数的尾数 M 的绝对值应满足条件 `1/r≤|M|≤1` （十进制就是 0.1 到 1.0）。

若 r=2，则有 `1/2≤|M|≤1` 。规格化表示的尾数形式如下。

1. 原码规格化后。

   正数为 `0.1xx...x` 的形式，其最大值表示为 `0.11...1` ，最小值表示为 `0.100...0` 。尾数的表示范围为 `1/2≤(1-2^-n)` 。

   负数为 `1.1xx...x` 的形式，其最大值表示为 `1.10...0` ，最小值表示为 `1.11...1` 。尾数的表示范围为 `-(1-2^-n)≤M≤-1/2` 。

2. 补码规格化后

   正数为 `0.1xx...x` 的形式，其最大值表示为 `0.11...1` ，最小值表示为 `0.100...0` 。尾数的表示范围为 `1/2≤M≤(1-2^-n)` 。

   负数为 `1.0xx...x` 的形式，其最大值表示为 `1.01...1` ，最小值表示为 `1.00...0` 。尾数的表示范围为 `-1≤M≤-(1/2+2^-n)` 。

   注意：这里补码规格化尾数的最大负数形式为 `1.01...1` ，而不是原码的形式 `1.10...0` ，因为 `1.10...0` 不是补码规格化数（如果取反加一后你会发现还是 `1.10...0`），所以规格化尾数的最大负数是 `-(0.10...0+0.0...01)=-0.10...01` ，而 `(-0.10...01)补=1.01...1` 。

当浮点数尾数的基数为 2 时，原码规格化数的最高位一定是 1，补码规格化数的尾数最高位一定与尾数符号位相反。基数不同，浮点数的规格化形式也不同。当基数为 4 时，原码规格化形式的尾数最高两位不全为 0；当基数为  8 时，原码格式化的形式的尾数最高 3 位不全为 0 。（基数为 4 的时候，0.01、0.10、0.11 都是正确的，化成四进制就是 0.1、0.2、0.3）

### 1.3 浮点数的表示范围（考研大纲已删，了解即可）

运算结果大于最大正数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称上溢。数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。当运算结果在 0 至最小正数之间时称为正下溢，在 0 至绝对值最小负数之间时称为负下溢，正下溢和负下溢统称下溢。数据下溢时，浮点数值趋于零，计算机仅将其当作机器零处理。

### 1.4 IEEE 754 标准

按照 IEEE 754 标准，常用的浮点数个数如下

```markdown
数符 + 阶码部分(用移码表示) + 尾数部分(用原码表示)
ms  +   E               +    M
```

IEEE 754 标准规定常用的浮点数格式有（单精度、float 型）、长浮点数（双精度、double 型）、临时浮点数。如下

| 类型       | 数符 | 阶码 | 尾数数值 | 总位数 | 偏置值       |
| ---------- | ---- | ---- | -------- | ------ | ------------ |
| 短浮点数   | 1    | 8    | 23       | 32     | 127(7FH)     |
| 长浮点数   | 1    | 11   | 52       | 64     | 1023(3FFH)   |
| 临时浮点数 | 1    | 15   | 64       | 80     | 16383(3FFFH) |

IEEE 754 标准的浮点数（除临时浮点数外），是尾数用采取隐藏位策略的原码表示，且阶码用移码表示的浮点数。

以短浮点数为例，最高位为数符位；其后是 8 位阶码，以 2 为底，用移码表示，阶码的偏置值为 `2^(8-1)-1=127` ；其后 23 位是原码表示的尾数数值位。对于规格化的二进制浮点数，数值的最高位总是 1 ，为了能使尾数多表示一位有效位，将这个 1 隐含，因此尾数数值实际上是 24 位。隐含的 1 是一位整数。在浮点格式中的 23 位尾数是纯小数。例如，(12)₁₀=(1100)₂ ，将它规格化后结果为 1.1×2³ ，其中整数部分的 1 将不存储在 23 位尾数内。

注意：短浮点数与长浮点数都采用隐含尾数最高数位的方法，故可多表示一位尾数。临时浮点数又称扩展精度浮点数，无隐含位。

阶码是以移码形式存储的。对于短浮点数，偏置值为 127；对于长浮点数，偏置值为 1023。存储浮点数阶码部分之前，偏置值要先加到阶码真值上。上例中，阶码值为 3，故在短浮点数中，移码表示的阶码为 127+3=130(82H) ；在长浮点数中，阶码为 1023+3=1026(402H) 。

IEEE 754 标准中，规格化的短浮点数的真值为 

```markdown
(-1)^s×1.M×2^(E-127)
```

规格化长浮点数的真值为 

```markdown
(-1)^(s)×1.M×2^(E-1023)
```

式中，s=0 表示正数，s=1 表示负数；短浮点数 E 的取值为 1~254(8 位表示) ，M 为 23 位，共 32 位；长浮点数 E 的取值为 1~2046(11 位表示) ，M 为 52 位，共 64 位。IEEE 754 标准浮点数（绝对值）的范围见下表

| 格式   | 最小值   | 最大值              |
| ------ | -------- | ------------------- |
| 单精度 | E=1，M=0 | E=254，M=`.11...1`  |
| 双精度 | E=1，M=0 | E=2046，M=`.11...1` |

### 1.5 定点、浮点表示的区别

1. 数值的表示范围

   若定点数和浮点数的字长相同，则浮点数表示法所能表示的数值范围将远远大于定点表示法。

2. 精度

   所谓精度，是指一个数所含有效数值位的位数。对于字长相同的定点数和浮点数来说，浮点数虽然扩大了数的表示范围，但精度降低了。

3. 数的运算

   浮点数包括阶码和尾数两部分，运算时不仅要做尾数的运算，还要做阶码的运算，而且运算结果要求规格化，所以浮点运算比定点运算复杂。

4. 溢出问题

   在定点运算中，当运算结果超出数的表示范围时，发生溢出；浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出。

## 2. 浮点数的加减运算

浮点数运算的特点是阶码运算和尾数运算分开进行。浮点数的加减运算一律采用补码。浮点数加减运算分为以下几步。（尾数表示用原码，运算用补码）

### 2.1 对阶

对阶的目的是使两个操作数的小数点位置对齐，即使得两个数的阶码相等。为此，先求阶差，然后以小阶向大阶看齐的原则，将阶码小的尾数右移一位（基数为 2），阶加 1，直到两个数的阶码相等为止。尾数右移时，舍弃掉有效位会产生误差，影响精度。

### 2.2 尾数求和

将对阶后的尾数按定点数加（减）运算规则运算。

### 2.3 规格化

以双符号位为例，当尾数大于 0 时，其补码规格化形式为

```markdown
[S]补 = 00.1xx...x
```

当尾数小于 0 时，其补码规格化形式为 

```markdown
[S]补 = 11.0xx...x
```

可见，当尾数的最高数值位与符号位不同时，即为规格化形式。规格化分为左规与右规两种。

1. 左规：当尾数出现 `00.0xx...x` 或 `11.1xx...x` 时，需左规，即尾数左移 1 位，和的阶码减 1，直到尾数为 `00.1xx...x` 或 `11.0xx...x` 。
2. 右规：当尾数求和结果溢出（如尾数为 `10.xx...x` 或 `01.xx...x`）时，需右规，即尾数右移一位，和的阶码加 1。

```markdown
1. 对于左规和右规，不应死记。考查尾数的大小，左规一次相当于乘 2，右规一次相当于除 2
2. [-1/2]补 = 1.1000 不是规格化数，需左规一次，[-1]补 = 1.0000 才是规格化数。
```

### 2.4 舍入

在对阶和右规的过程中，可能会将尾数低位丢失，引起误差，影响精度。常见的舍入方法有：0 舍 1 入法和恒置 1 法。

1. 0 舍 1 入法：类似于十进制数运算中的 "四舍五入" 法，即在尾数右移时，被移出的最低数值位为 0，则舍去；被移去的最低数值位为 1，则在尾数的末位加 1。这样做可能会使尾数又溢出，此时需再做一次右规。
2. 恒置 1 法：尾数右移时，不论丢掉的最高数值位是 1 还是 0 ，都使右移后的尾数末位恒置 1 。这种方法同样有使尾数变大和变小的两种可能。

### 2.5 溢出判断

与定点数加减法一样，浮点数加减运算最后一步也需判断溢出。

在浮点数规格化中已指出，当尾数之和（差出现） `01.xx...x` 或 `10.xx...x` 时，并不表示溢出，只能将此数右规后，再根据阶码来判断浮点数运算结果是否溢出。

浮点数的溢出与否是由阶码的符号决定的。以双符号位补码为例，当阶码的符号位出现 01 时，即阶码大于最大阶码时，表示上溢，进入中断处理；当阶码的符号位出现 10 时，即阶码小于最小阶码时，表示下溢，按机器零处理。实际上原理还是阶码符号位不同表示溢出，且真实符号位和高位符号位一致（10 中的 1 表示真实符号）。

### 2.6 强制类型转换

C 语言中，在等式的赋值和判断中会出现强制类型转换。以 `char→int→long→double` 和 `float→double` 最为常见，从前到后范围和精度都从小到大，转换过程中没有损失。以下是几个比较重要的转换过程。

1. char 为 8 位 ASCII 码整数，转换为 `int`，在前面补 0。

2. `int` 和 `unsigned int` 可以互相转换，但彼此都可能因溢出而造成数据丢失，如 8 位 `int` 和 `unsigned int` 。

   ```c
   int a = -1;
   (unsigned int)a = 255;
   unsigned int b = 128;
   int(b) = -128;
   ```

3. `int` 和 `float` 转换，若 `float` 是小数，则转换为 `int` 可能会发生精度损失（小数仅保留整数部分）和溢出，从 `int` 转换为 `float` 时，虽然不会发生溢出，但 `int` 可以保留 32 位，`float` 保留 24 位，可能有数据舍入，`double` 则不会出现。 

## 3. 习题

1. 浮点数的加减运算过程？
2. IEEE 754 浮点数表示
3. 浮点数的基数体现在哪？
4. 基数越大，精度和范围的变化？
5. 判断浮点数是否是规格化数需要注意什么？
6. n 位阶码的移码表示范围？
7. 阶码全 1，尾数全 0 代表什么？
8. 强制转换后的 float 是怎么样的？

## 4. 习题答案

1. 主要分以下步骤
   1. 根据符号位、阶码、尾数规格，将十进制数写成标准的浮点数格式（重要）
   2. 判断是用双符号位还是单符号位（重要）
   3. 对阶。小的往大的对阶（这一步不可能溢出，单导致小的精度丢失）
   4. 尾数运算。（一般都是补码计算，审题看是否需要化为原码）
   5. 规格化（尾数根据双符号和最高位的区别进行左规或右规）
   6. 舍入（0 设 1 入法或置 1 法）
   7. 判断溢出（查看阶码的双符号位是否不同，如果不同，发生溢出）
2. 1、8、23，其中尾数是原码表示，为 1.xxx，阶码 8 位，换算时一定要减 127，阶码范围是 1~254，尾数部分是数值部分，不含符号位，所以范围是 1.00...00 到 1.11...11
3. 浮点数的基数体现在阶码的底数上，和浮点数格式无关，计算机默认为 2，若基数为 4，则 16 可以表示为 1×4²。所以一般会问阶的基数，尾数的补码或原码表示。
4. 精度越小，范围越大。因为浮点数的格式限制了表示的数目，所以范围打了，自然精度就小了。 
5. 如果没有说明原码还是补码，那么都要满足。注意基数不同，规格化数也就不同，原码情况下基数 2 时最高位为 1，基数 4 时前 2 位不全为 0，基数 8 时前 2 位不全为 0
6. 1~2^n-2，偏置值为 2^(n-1)-1。例如 7 位，表示范围是 1~126，偏置值为 63
7. 代表无穷；阶码为 0，尾数全 0 代表 机器数 0。
8. 从 `int` 到 float 可能会导致精度缺失，然后 float 再转换回 `int` 就导致了结果和之前不一样了。

