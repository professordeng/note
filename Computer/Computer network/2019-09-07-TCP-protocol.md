---
title: 5.3 TCP 协议
date: 2019-11-27
---

## 1. TCP 协议的特点

TCP 协议是在不可靠的 IP 层之上实现的可靠的数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。TCP 是 TCP/IP 体系中非常复杂的一个协议，主要特点如下：

1. TCP 是面向连接的传输层协议。

2. 每条 TCP 连接只能有两个端点，每条 TCP 连接只能是点对点的（一对一）。

3. TCP 提供可靠的交付服务，保证传送的数据无差错、不丢失、不重复且有序。

4. TCP 提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此 TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。

   发送缓存用来暂时存放以下数据：①发送应用程序传送给发送方 TCP 准备发送的数据；②TCP 已发送但尚未收到确认的数据。接收缓存用来暂时存放以下数据：①按序到达但尚未被接收应用程序读取的数据；②不按序到达的数据。

5. TCP 是面向字节流的，虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅视为一连串的无结构的字节流。

## 2. TCP 报文段

TCP 传送的数据单元称为报文段。一个 TCP 报文段分为 TCP 首部和 TCP 数据部分，整个 TCP 段作为 IP 数据报的数据部分封装在 IP 数据报中。其首部的前 20B 是固定的。TCP 报文段的首部最短为 20B，后面有 4N 字节是根据需要而增加的选项，通常长度为 4B 的整数倍。

![TCP](/computer-network/img/tcp.png)

TCP 报文段既可以用来装载数据，又可以用来建立连接、释放连接和应答。

各字段意义如下：

1. 源端口和目的端口字段

   各占 2B，端口是传输层与应用层的服务接口，传输层的复用和分用功能都要通过端口实现。

2. 序号字段

   占 4B。TCP 是面向字节流的（即 TCP 传送时是逐个字节传送的），所以 TCP 连接传送的数据流中的每个字节都编上一个序号。序号字段的值指的是本报文段所发送的数据的**第一个字节**的序号。

   例如，一个报文段的序号字段值是 301，而携带的数据共有 100B，表明本报文段的数据的最后一个字节的序号是 400，故下一个报文段的数据序号应从 401 开始。

3. 确认号字段

   占 4B，是期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为 N，则表明到序号 N-1 为止的所有数据都已正确收到。

   例如，B 正确收到 A 发送过来的一个报文段，其序号字段是 501，而数据长度是 200B（序号 501~700），这表明 B 正确收到了 A 发送的到 700 为止的数据。因此 B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认好置为 701。

4. 数据偏移（即首部长度）

   占 4 位，这里不是 IP 数据报分片的那个数据偏移，而是表示**首部长度**，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。

   “数据偏移” 的单位是 32 位（以 4B 为计算单位）。因此当此字段的值为 15 时，达到 TCP 首部的最大长度 60B 。

5. 保留字段

   占 6 位，保留为今后使用，但目前应置为 0，该字段可以忽略不计。

6. 紧急位 URG

   URG=1 时，表明紧急指针字段有效。它告诉系统报文段中有紧急数据，应尽快传送（相当于高优先级的数据）。但 URG 需要和紧急指针配套使用，即数据从第一个字节到紧急指针所指字节就是紧急数据。

7. 确认位 ACK

   只有当 ACK=1 时确认号字段才有效。当 ACK=0 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

8. 推送位 PSH（Push）

   接收 TCP 收到 PSH=1 时的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满后再向上交付。

9. 复位位 RST（Reset）

   RST=1 时，表明 TCP 连接中出现严重差错（如主机崩溃或其他原因），必须释放连接，然后再重新建立运算连接。

10. 同步位 SYN

    同步 SYN=1 表示这是一个连接请求或连接接收报文。

    当 SYN=1，ACK=0 时，表明这是一个连接请求报文，对方若同意建立连接，则在响应报文中使用 SYN=1，ACK=1。即 SYN=1 表示这是一个连接请求或连接接收报文。

11. 终止位 FIN（Finish）

    用来释放一个连接。FIN=1 表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。

12. 窗口字段

    占 2B。它指出现在允许对方发送的数据量，接收方的数据缓存空间是有限的，故用窗口值作为接收方让发送方设置其发送窗口的依据，单位是字节。

    例如，设确认号是 701，窗口字段是 1000。这表明，从 701 号算起，发送此报文段的一方还有接收 1000B 数据（字节序号为 701~1700）的接收缓存空间。

13. 校验和

    占 2B。校验和字段校验的范围包括首部和数据两部分。在计算校验和时，和 UDP 一样，要在 TCP 报文段的前面加上 12B 的伪首部（只需将 UDP 伪首部的第 4 个字段，即协议字段的 17 改成 6，其他的和 UDP 一样）。

14. 紧急指针字段

    占 16 位，指出在本报文段中紧急数据共有多少字节（紧急数据放在本报文段数据的最前面）。

15. 选项字段

    长度可变。TCP 最初只规定了一种选项，即最大报文段长度（Maximum Segment Size，MSS）。MSS 是 TCP 报文段中的数据字段的最大长度。

16. 填充字段，这是为了使整个首部长度是 4B 的整数倍。

## 3. TCP 连接管理

TCP 是面向连接的协议，因此每个 TCP 连接都有三个阶段：建立连接、数据传送和连接释放。TCP 连接的管理就是使运输连接的建立和释放都能正常进行。

在 TCP 连接建立的过程中，要解决以下三个问题：

1. 要使每一方都能够确知对方的存在。
2. 要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项、时间戳选项及服务质量等）。
3. 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。

TCP 把连接作为最基本的抽象，每条 TCP 连接有两个端点，TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是传输层的协议端口。TCP 连接的端口称为套接字（socket）或插口。端口拼接到 IP 地址即构成套接字。

每条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）确定。

TCP 连接的建立采用客户/服务器方式。主动发起连接建立的应用进程称为客户机（Client），而被动等待连接建立的应用进程称为服务器（Server）。

### 3.1 TCP 连接的建立

连接的建立经历以下 3 个步骤，通常称为三次握手。

第一步：客户机的 TCP 首先向服务器的 TCP 发送一个**连接请求报文段**。这个特殊的报文段中不含应用层数据，其首部中的 SYN 标志位被置为 1。另外，客户机会随机选择一个起始序号 seq=x（连接请求报文不携带数据，但要消耗一个序号）

第二步：服务器的 TCP 收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并为该 TCP 连接分配 TCP 缓存和变量。在确认报文段中，SYN 和 ACK 都被置为 1，确认号字段的值为 x+1，并且服务器随机产生起始序号 seq=y（确认报文不携带数据，但也要消耗一个序号）。确认报文段同样不包含应用层数据。

第三步：当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的 ACK 标志位被置 1，序号字段为 x+1，确认号字段为 ack=y+1。该报文段可以携带数据，若不携带数据则不消耗序号。

成功进行以上三步后，就建立了 TCP 连接。接下来就可以传送应用层数据。TCP 提供的是**全双工通信**，因此通信双方的应用进程在任何时候都能发送数据。

另外，值得注意的是，服务器端的资源是在完成第二次握手时分配的，而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于收到 SYN 洪泛攻击。

### 3.2 TCP 连接的释放

 参与 TCP 连接的两个进程中的任何一个都能终止该连接。TCP 连接释放的过程通常称为四次握手。

第一步，客户机打算关闭连接时，向其 TCP 发送一个连接释放报文段，并停止发送数据，主动关闭 TCP 连接，该报文段的 FIN 标志位被置 1，seq=u，它等于前面已传送过的数据的最后一个字节的序号加 1（FIN 报文段即使不携带数据，也要消耗一个序号）。TCP 是全双工的，即可以想象为一条 TCP 连接上有两条数据通路。发送 FIN 报文时，发送 FIN 的一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据。

第二步：服务器收到连接释放报文段后即发出确认，确认号是 ack=u+1，而这个报文段自己的序号是 v，等于它前面已传送过的数据的最后一个字节的序号加 1。此时，从**客户机到服务器**这个方向的连接就释放了，TCP 连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从**服务器到客户机这个方向**的连接并未关闭。

第三步：若服务器已经没有要向客户机发送的数据，就通知 TCP 释放连接，此时其发出 FIN=1 的连接释放报文段。

第四步：客户机收到连接释放报文段后，必须发出确认。在确认报文段中，ACK 字段被置为 1，确认号 ack=w+1，序号 seq=u+1。此时 TCP 连接还未释放，必须经过时间等待计时器设置的时间 2MSL 后，客户机才进入关闭状态。

对上述 TCP 连接建立和释放的总结如下：

1. 连接建立。分为 3 步：
   1. SYN=1，seq=x
   2. SYN=1，ACK=1，seq=y，ack=x+1
   3. ACK=1，seq=x+1，ack=y+1
2. 释放连接。分为 4 步
   1. FIN=1，seq=u
   2. ACK=1，seq=v，ack=u+1
   3. FIN=1，ACK=1，seq=w，ack=u+1
   4. ACK=1，seq=u+1，ack=w+1

选择题喜欢考察（关于连接和释放的题目，ACK、SYN、FIN 一定等于 1），请牢记。

## 4. TCP 可靠传输

TCP 的任务是在 IP 层不可靠的、尽力而为服务的基础上建立一种**可靠数据传输服务**。TCP 提供的可靠数据传输服务保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一样。TCP 使用了校验、序号、确认和重传等机制来达到这一目的。其中，TCP 的校验机制与 UDP 校验一样，这里不再赘述。

### 4.1 序号

TCP 首部的序号字段用来保证数据能有序提交给应用层，TCP 把数据视为一个无结构但有序的字节流，序号建立在传送的**字节流**之上，而不建立在报文段之上。

TCP 连接传送的数据流中的每个字节都编上一个序号。序号字段的值是指本报文段所发送的数据的第一个字节的序号。假设 A 和 B 之间建立了一条 TCP 连接，A 的发送缓存区中有 10B，序号从 0 开始标号，第一个报文包含第 0~2 个字节，则该 TCP 报文段的序号是 0，第二个报文段的序号是 3。

```c++
第一个报文段的数据    第二个     第三个      第四个
    0 1 2       |  3 4   |   5 6 7  |   8 9
```

### 4.2 确认

TCP 首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。如果接收方 B 已收到第一个报文段，此时 B 希望收到的下一个报文段的数据是从第 3 个字节开始的，那么 B 发给 A 的报文段中的确认号字段应为 3。发送方缓存区会继续存储那些已发送但未收到确认的报文段，以便在需要时重传。

TCP 默认使用累计确认，即 TCP 只确认数据流中至第一个丢失字节为止的字节。例如，接收方 B 收到了 A 发送的包含字节 0~2 及字节 6~7 的报文段。由于某种原因，B 还未收到字节 3~5 的报文段，此时 B 仍在等待字节 3（和其后面的字节），因此 B 到 A 的下一个报文段将确认号字段置为 3。（窗口机制使得后面的不需要重传）

### 4.3 重传

有两种事件会导致 TCP 对报文段进行重传：超时和冗余 ACK。

1. 超时

   TCP 每发送一个报文段，就对这个报文段置一次计时器。计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段。

   由于 TCP 的下一层是一个互联网环境，IP 数据报所选择的路由变化很大，因而传输层的往返时延的方差也很大。为了计算超时计时器的重传时间，TCP 采用一种自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差称为报文段的往返时间（Round-Trip Time，RTT）。TCP 保留了 RTT 的一个加权平均往返时间 RTT_S，当第一次测量 RTT 样本时，RTT_S 值就为所测量到的 RTT 样本的值，但以后每测量一个新的 RTT 样本，就按下式重新计算一次 RTT_S：

   ```c++
   新RTT_S=(1-α)×(旧RTT_S)+α×(新RTT样本)
   ```

   式中，0≤α<1。若 α 接近于零，表示新 RTT_S 值和旧 RTT_S 值相比变化不大，且受新 RTT 样本的影响不大（RTT 值更新较慢）。若选择 α 接近于 1，则表示新 RTT_S 值受新 RTT 样本的影响较大（RTT 值更新较快）。RFC 2988 推荐的 α 值为 0.125 。

   显然，超时计时器设置的超时重传时间（Retransmission Time-Out，RTO）应略大于上面得出的加权平均往返时间 RTTs，它使用下式计算：

   ```c++
   RTO=RTT_S + 4×RTT_D
   ```

   式中，RTT_D 是 RTT 的偏差的加权平均值，它与 RTT_S 和新 RTT 样本之差有关。第一次测量时，RTT_D 取为测量到的 RTT 样本值的一半，在以后的测量中，使用下式计算：

   ```c++
   新RTT_D = (1-β)×(旧 RTT_D)+β×|RTT_S-新RTT样本|
   ```

   式中，β 是个小于 1 的系数，它的推荐值是 0.25 。

2. 冗余 ACK（冗余确认）

   超时触发重传存在的一个问题是超时周期往往太长。所幸的是，发送方通常可在超时事件发生之前通过注意所谓的冗余 ACK 来较好地检测丢包情况。冗余 ACK 就是**再次确认**某个报文段的 ACK，而发送方先前已经收到过该报文段的确认。例如，发送方 A 发送了序号为 1、2、3、4、5 的 TCP 报文段，其中 2 号报文段在链路中丢失，它无法到达接收方 B。因此 3、4、5 号报文段对于 B 来说就成了失序报文段。TCP 规定每当比期望序号大的失序报文段到达时，就发送一个冗余 ACK，指明下一个期待字节的序号 `[RFC 1122,RFC 2581]` 。在本例中，3、4、5 号报文到达 B，但它们不是 B 所期望收到的下一个报文，于是 B 就发送 3 个对 1 号报文段的冗余 ACK，表示自己期望收到 2 号报文段。TCP 规定当发送方收到对同一个报文段的 3 个冗余 ACK 时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。就前面的例子而言，当 A 收到对于 1 号报文段的 3 个冗余 ACK 时，它可以认为 2 号报文段已经丢失。这时发送方 A 可以立即对 2 号报文执行重传，这种技术通常称为**快速重传**。当然，冗余 ACK 还被用在拥塞控制中，这将在后面的内容中讨论。

## 5. TCP 流量控制

TCP 提供流量控制服务来消除发送方使接收方缓存区溢出的可能性，因此可以说流量控制是一个速度匹配服务（匹配发送方的发送速率与接收方的读取速率）。

TCP 提供一种基于**滑动窗口协议**的流量控制机制，滑动窗口的基本原理已在第 3 章的数据链路层介绍过，这里要介绍的是 TCP 如何使用窗口机制来实现流量控制。

在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为接收窗口 rwnd，即调整 TCP 报文段首部中的 “窗口” 字段值，来限制发送方向网络注入报文的速率。同时，发送方根据其对当前网络拥塞程序的估计而确定的窗口值，这称为拥塞窗口 cwnd（后面会讲到），其大小与网络的带宽和时延密切相关。

例如，在通信中，有效数据只从 A 发往 B，而 B 仅向 A 发送确认报文，这时 B 可以通过设置确认报文段首部的窗口字段来将 rwnd 通知给 A。rwnd 即接收方允许连续接收的最大能力，单位是字节。发送方 A 总是根据**最新**收到的 rwnd 值来限制自己发送窗口的大小，从而将未确认的数据量控制在 rwnd 大小之内，保证 A 不会使 B 的缓存溢出。当然，A 的发送窗口的实际大小取 rwnd 和 cwnd 中的最小值。

设主机 A 向主机 B 发送数据，在连接建立时，B 告诉 A：“我的接收窗口 rwnd=400(字节)” 。下面代码就说明了如何利用滑动窗口机制进行流量控制。

```c++
主机A                          主机B
|-------seq=1,DATA-------------->|  A 发送了序号1至100，还能发送300字节
|-------seq=101,DATA------------>|  A 发送了序号101至200，还能发送200字节
|-------seq=201,DATA----->突然丢失| 
|<---ACK=1,ack=201,rwnd=300------|  允许 A 发送序号 201 至 500 共 300 字节
|-------seq=301,DATA------------>|  A 发送了序号301至400，还能发送100字节新数据
|-------seq=401,DATA------------>|  A 发送了序号401至500，不能再发送新的数据了
|-------seq=201,DATA------------>|  A 超时重发旧的数据，但不能发送新的数据
|---ACK=1,ack=501,rwnd=100------>|  允许 A 发送序号 501至600共100字节
|-------seq=501,DATA------------>|  A 发送了序号501至600，不能再发送了
|---ACK=1,ack=601,rwnd=0-------->|  不允许 A 再发送（到序号600为止的数据都收到了）
```

传输层和数据链路层的流量控制的区别是：传输层定义端对端用户之间的流量控制，数据链路层定义两个中间的相邻结点的流量控制。另外，数据链路层的滑动窗口协议的窗口大小不能动态变化，传输层的则可以动态变化。

## 6. TCP 拥塞控制

所谓拥塞控制，是指防止过多的数据注入网络，以使网络中的路由器或链路不致过载。出现拥塞时，端点并不了解到拥塞发生的细节，对通信连接的端点来说，拥塞往往表现为通信时延的增加。当然，拥塞控制和流量控制也有相似的地方，即它们都通过控制发送方发送数据的速率来达到控制效果。

拥塞控制与流量控制的区别：拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是指点对点的通信量的控制，即接收端控制发送端，它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。

例如，某个链路的传输速率为 10Gb/s，某巨型机向一台 PC 以 1Gb/s 的速率传送文件，显然网络的带宽是足够大的，不存在拥塞问题，但如此高的发送速率将导致 PC 可能来不及接收，因此必须进行流量控制。但若有 100 万台 PC 在此链路上以 1Mb/s 的速率传送文件，则现在的问题就变为网络的负载是否超过了现有网络所能承受的范围。

为了更好地对传输层进行拥塞控制，因特网建议标准定义了以下 4 种算法：慢开始、拥塞避免、快重传、快恢复。

发送方在确定发送报文段的速率时，既要根据发送方的接收能力，又要从全局考虑不要使网络发生拥塞。因此，TCP 协议要求发送方维护以下两个窗口：

1. 接收窗口 rwnd，接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量。由接收方根据其放在 TCP 报文的首部的窗口字段通知发送方。
2. 拥塞窗口 cwnd，发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络的当前容量。只要网络未出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入网络的分组数。

发送窗口的上限值应取接收窗口 rwnd 和拥塞窗口 cwnd 中较小的一个，即

```markdown
发送窗口的上限值 = min{rwnd, cwnd}
```

注意：接收方总有足够大的缓存空间，因而发送窗口大小由网络的拥塞程度决定，也就是说，可以将发送窗口等同为拥塞窗口。

接收窗口的大小可根据 TCP 报文首部的窗口字段通知发送方，而发送方如何维护拥塞窗口呢？这就是下面讲解的慢开始和拥塞避免算法。

### 6.1 慢开始和拥塞避免

1. 慢开始算法

   在 TCP 刚刚连接好并开始发送 TCP 报文段时，先令拥塞窗口 cwnd=1，即一个最大报文段长度 MSS。每收到一个对新报文段的确认后，将 cwnd 加 1，即增大一个 MSS。用这样的方法逐步增大发送方的拥塞窗口 cwnd，可使分组注入网络的速率更加合理。

   例如，A 向 B 发送数据，发送时 A 的拥塞窗口为 2，那么 A 一次可以发送两个 TCP 报文段，经过一个 RTT 后（也称一次传输轮次），A 收到 B 对刚才两个报文的确认，于是把拥塞窗口调整为 4，下一次发送时就可一次发送 4 个报文段。

   使用慢开始算法后，每经过一个传输轮次（即往返时延 RTT），拥塞窗口 cwnd 就会加倍，即 cwnd 的大小指数式增加。这样，慢开始一直把拥塞窗口 cwnd 增大到一个规定的慢开始门限 ssthresh（阈值），然后改用拥塞避免算法。

2. 拥塞避免算法

   拥塞避免算法的做法如下：发送端的拥塞窗口 cwnd 每经过一个往返时延 RTT 就增加一个 MSS 的大小，而不是加倍，使 cwnd 按线性规律缓慢增长（即加法增大），而当出现一次超时（网络拥塞）时，令慢开始门限 ssthresh 等于当前 cwnd 的一半（即乘法减小）。

   根据 cwnd 的大小执行不同的算法，可归纳如下：

   1. 当 cwnd < ssthresh 时，使用慢开始算法。
   2. 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法
   3. 当 cwnd = ssthresh 时，即可使用慢开始算法，又可使用拥塞避免算法（通常做法）。

3. 网络拥塞的处理

   网络出现拥塞时，无论是在慢开始阶段还是在拥塞避免阶段。只要发送方检测到超时事件的发送（未按时收到确认，重传计时器超时），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方的 cwnd 值的一半（但不能小于 2）。然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。 

拥塞避免并不完全能避免拥塞。利用以上措施要完全避免网络拥塞是不可能的。拥塞避免是指在拥塞避免阶段把拥塞窗口控制为线性规律增长，使网络比较不容易出现拥塞。

慢开始和拥塞避免算法的实现过程如下

1. 初始时，拥塞窗口置 1，即 cwnd=1，慢开始门限置为 16，即 ssthresh=16。慢开始阶段，cwnd 的初值为 1，以后发送方每收到一个确认 ACK，cwnd 值加 1，也即经过每个传输轮次（RTT），cwnd 呈指数规律增长。
2. 拥塞窗口 cwnd 增长到慢开始门限 ssthresh 时（即当 cwnd=16 时），就改用拥塞避免算法，cwnd 按线性规律加性增长。
3. 假定 cwnd=24 时网络发生拥塞，更新 ssthresh 的值为 12（即变为超时时 cwnd 值 24 的一半），cwnd 重置 1，并执行慢开始算法，cwnd=12 时，改用拥塞避免算法。

注意在慢开始（指数级增长）阶段，若 2cwnd>ssthresh，则下一个 RRT 的 cwnd 等于 ssthresh，而不等于 2cwnd，即 cwnd 不能跃过 ssthresh，也就是步骤 3 过后，有一轮是 cwnd=8，ssthresh=12，在下一轮时 cwnd=12，而不等于 16。

在慢开始和拥塞避免算法中使用了 “乘法减小” 和 “加法增大” 方法。“乘法减小” 是指不论是慢开始阶段还是在拥塞避免阶段，只要出现一次超时（即很可能出现了网络拥塞），就把慢开始门限值 ssthresh 设置为当前拥塞窗口值的一半。网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入网络的分组数。而 “加法增大” 是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个 RTT），就把拥塞窗口 cwnd 增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。

### 6.2 快重传和快恢复

快重传和快恢复算法是对慢开始和拥塞避免算法的改进。

1. 快重传

   在上一节介绍的 TCP 可靠传输机制中，快重传技术使用了冗余 ACK 来检测丢包的发生。同样，冗余 ACK 也用于网络拥塞的检测（丢了包当然意味着网络可能出现了拥塞）。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。

   当发送方连续收到三个重复的 ACK 报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。

2. 快恢复

   快恢复算法的原理如下：发送端收到连续三个冗余 ACK（即重复确认）时，执行 “乘法减小” 算法，把慢开始门限 ssthresh 设置为出现拥塞时发送方 cwnd 的一半。与慢开始（慢开始算法将拥塞窗口 cwnd 设置为 1）的不同之处是，它把 cwnd 的值设置为慢开始门限 ssthresh 改变后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

   由于跳过了 cwnd 从 1 起始的慢开始过程，所以被称为快恢复。

在流量控制中，发送方发送数据的量由接收方决定，而在拥塞控制中，则由发送方自己通过检测网络状况来决定。实际上，慢开始、拥塞避免、快重传和快恢复几种算法应是同时应用在拥塞控制机制之中的，当发送方检测到超时的时候，就采用慢开始和拥塞避免，当发送方接收到冗余 ACK 时，就采用快重传和快恢复。

最后提醒各位：发送方发送窗口的实际大小由流量控制和拥塞控制共同决定。因此，当题目中同时出现接收端窗口（rwnd）和拥塞窗口（cwnd）时，发送方实际的发送窗口大小是由 rwnd 和 cwnd 中较小的那一个确定的。

## 7. 习题

## 8. 习题答案

