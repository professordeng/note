---
title: 5.2 UDP 协议
date: 2019-11-26
---

## 1. UDP 数据报

### 1.1 UDP 概述

RFC 768 定义的 UDP 只是做了**传输协议能够做的最少工作**，它仅在 IP 的数据报服务之上增加了两个最基本的服务：复用和分用以及**差错检测**。如果应用程序开发者选择 UDP 而非 TCP，那么应用程序几乎直接与 IP 打交道。

有很多应用更适合用 UDP，主要因为 UDP 具有如下优点：

1. UDP 无须建立连接。因此 UDP 不会引入建立连接的时延。试想如果 DNS 运行在 TCP 而非 UDP 上，那么 DNS 的速度会慢很多。HTTP 使用 TCP 而非 UDP，是因为对于基于文本数据的 Web 网页来说，可靠性是至关重要的。
2. 无连接状态。TCP 需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数和序号与确认号的参数。而 UDP 不维护连接状态，也不跟踪这些参数。因此，某些专用应用服务器使用 UDP 时，一般都能支持更多的活动客户机。
3. 分组首部开销小。TCP 有 20B 的首部开销，而 UDP 仅有 8B 的开销。
4. 应用层能更好地控制要发送的数据和发送时间。UDP 没有拥塞控制，因此网络中的拥塞不会影响主机的发送效率。某些实时应用要求以稳定的速度发送，能容忍一些数据的丢失，但不允许有较大的时延，而 UDP 正好满足这些应用的需求。

UDP 常用于一次性传输较少数据的网络应用，如 DNS、SNMP 等，因为对于这些应用，若采用 TCP，则将为连接船家女、维护和拆除带来不小的开销。UDP 也常用于多媒体应用（如 IP 电话、实时视频会议、流媒体等），显然，可靠数据传输对这些应用来说并不是最重要的，但 TCP 的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的。

UDP 提供尽最大努力的交付，即不保证可靠交付，但这并不意味着应用对数据的要求是不可靠的，因此所有维护传输可靠性的工作需要用户在应用层来完成。应用实体可以根据应用的需求来灵活设计自己的可靠性机制。

UDP 是面向报文的。发送方 UDP 对应用层交下来的报文，在添加首部后就向下交付给 IP 层，即不合并，也不拆分，而是保留这些报文的边界；接收方 UDP 对 IP 层交上来 UDP 用户数据报，在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文。因此**报文不可分割，是 UDP 数据报处理的最小单位**。

### 1.2 UDP 的首部格式

UDP 数据报包含两部分：UDP 首部和用户数据，整个 UDP 数据报作为 IP 数据报的数据部分封装在 IP 数据报中。UDP 首部有 8B，由 4 个字段组成，每个字段的长度都是 2B，各字段意义如下：

1. 源端口

   源端口号。在需要对方回信时选用，不需要时可用全 0

2. 目的端口

   目的端口号。这在终点交付报文时必须使用到。

3. 长度

   UDP 数据报的长度（包括首部和数据），其最小值是 8（仅有首部）。

4. 检验和

   检测 UDP 数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全 0。

当传输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口上交给应用进程。

如果接收方 UDP 发现收到的报文中的目的端口号不正确（即不存在对应于端口号的应用进程），那么就丢弃该报文，并由 ICMP 发送 “端口不可达” 差错报文给发送方。

## 2. UDP 校验

在计算校验和时，要在 UDP 数据报之前增加 12B 的伪首部，伪首部并不是 UDP 的真正首部。只是在计算校验和时，临时添加在 UDP 数据报的前面，得到一个临时的 UDP 数据报。校验和就是按照这个临时的 UDP 数据报计算的。伪首部既不向下传送也不向上递交，而仅为了计算校验和。这样的校验和，即检查了 UDP 数据报，又对 IP 数据报的源 IP 和目的 IP 地址进行了校验。

```markdown
临时 UDP 数据报 = 伪首部 + UDP 数据报
伪首部 = 4B源IP地址 + 4B目的IP地址 + 1B(0) + 1B(17) + 2B(UDP长度)
UDP数据报 = 首部+数据
首部= 2B源端口 + 2B目的端口 + 2B长度 + 2B校验和
```

UDP 校验和的计算方法和 IP 数据报首部校验和的计算方法相似，都使用二进制反码运算求和再取反。但不同的是，IP 数据报的校验和只校验 IP 数据报的首部，但 UDP 的校验和则检查首部和数据部分。

发送方首先把全零放入校验和字段并添加伪首部，然后把 UDP 数据报视为许多 16位的字连接起来。若 DUP 数据报的数据部分不是偶数个字节，则要再数据部分末尾增加一个全零字节（但此字节不发送）。接下来按二进制反码计算出这些 16 位字的和。并将此和的二进制反码写入校验和字段。接收方把收到的 UDP 数据报加上伪首部（如果不为偶数个字节，那么还需要补上全零字节）后，按二进制反码计算出这些 16 位字的和。当无差错时其结果应全为 1，否则表明有差错出现，接收方就应该丢弃这个 UDP 数据报。

注意：

1. 校验时，若 UDP 数据报部分的长度不是偶数个字节，则需填入一个全 0 字节，但是此字节和伪首部一样，是不发送的。
2. 如果 UDP 校验和校验出 UDP 数据报是错误的，那么可以丢弃，也可以交付给上层，但是需要附上错误报告，即告诉上层这是错误的数据报。
3. 通过伪首部，不仅可以检查源端口号、目的端口号和 UDP 用户数据报的数据部分，还可以检查 IP 数据报的源 IP 地址和目的地址。

这种简单的差错校验方法的检错能力并不强，但它的好处是简单、处理速度快。

### 2.1 例子

通过加首部以及判断是否需要补零等措施后，按 2B 一个单位，然后取反相加，求得的和再取反得到校验和。

例如我们有 3 个 2B 字，取反后的字如下

```c++
0110011001100000
0101010101010101
1000111100001100
```

1. 对 3 个 16比特的字依次相加，由于此时已经都是反码，直接相加即可。

   ```c++
      0110 0110 0110 0000 
   +  0101 0101 0101 0101
   ------------------------------
      1011 1011 1011 0101
   +  1000 1111 0000 1100 
   --------------------------------
   = 10100 1010 1100 0001
   ```

2. 回卷，由于进位后多了第 17 位，要消除 17 位，将 17 位的 1 加到后 16 位上，得到结果。

   ```c++
     0100 1010 1100 0001
   +                   1
   -------------------------
     0100 1010 1100 0010
   ```

3. 再取反，得到

   ```c++
   1011 0101 0011 1101
   ```

4. 将这个值写入校验和字段中。

5. 在接收方中，将全部的 4 个 16 比特的字（包含了校验和）加在一起，没有差错的话，就是

   ```c++
   1111 1111 1111 1111
   ```


## 3. 习题

1. UDP 数据报比 IP 数据报多提供了什么服务？
2. 如果校验和计算结果为 0，校验和字段填充？

## 4. 习题答案

1. 端口功能
2. 全 1

