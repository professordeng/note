---
title: 5. 传输层
date: 2019-11-24
---

1. MSS 设置得太大或太小会有什么影响？

   规定最大报文段 MSS 的大小并不是考虑到接收方的缓存可能放不下 TCP 报文段。实际上，MSS 与接收窗口没有关系。TCP 的报文段的数据部分，至少要加上 40B 的首部（TCP 首部至少 20B 和 IP 首部至少 20B），才能组装成一个 IP 数据报。若选择较小的 MSS 值，网络的利用率很低。设想在极端情况下，当 TCP 报文段中只含有 1B 的数据时，在 IP 层传输的数据报的开销至少有 40B。这样，网路的利用率就不会超过 1/41。到了数据链路层还要加上一些开销，网络的利用率进一步降低。但反过来，若 TCP 报文段很长，那么在 IP 层传输时有可能要分解成多个短数据报片，在终端还要把收到的各数据报片装配成原来的 TCP 报文段。传输有差错时，还要进行重传。这些都会使开销增大。

   因此，MSS 应尽量大一些，只要在 IP 层传输时不要再分片就行。由于 IP 数据报所经历的路径是动态变化的，在一条路径上确定的不需要分片的 MSS，如果改走另一条路径，就可能需要进行分片。因此，最佳的 MSS 是很难确定的。MSS 的默认值为 536B，因此在因特网上的所有主机都能接收的报文段长度是 536+20xTCP固定首部长度=556B。

2. 为何不采用 “三次提手” 释放连接，且发送最后一次握手报文后要等待 2MSL 的时间呢？

   原因有两个：

   1. 保证 A 发送的最后一个确认报文段能够到达 B。如果 A 不等待 2MSL，若 A 返回的最后确认报文段丢失，则 B 不能进入正常关闭状态，而 A 此时已经关闭，也不可能再重传。
   2. 防止出现 “已失效的连接请求报文段”。A 在发送最后一个确认报文段后，再经过 2MSL 可保证本连接持续的时间内所产生的所有报文段从网络中消失。造成错误的情形与下文（疑难点 6）不采用 “两次握手” 建立连接所述的情形相同。

   注意：服务器结束 TCP 连接的时间要比客户端早一些，因为客户机最后要等待 2MSL 后才可进入 CLOSED 状态。

3. 如何判定此确认报文段是对原来的报文段的确认，还是对重传的报文段的确认？

   由于对于一个重传报文的确认来说，很难分辩它是原报文的确认还是重传报文的确认，使用修正的 Karn 算法作为规则：在计算平均往返时间 RTT 时，只要报文段重传了，就不采用其往返时间样本，且报文段每重传一次，就把 RTO 增大一些。

4. TCP 使用的是 GBN 还是选择重传？

   这是一个有必要弄清的问题。前面讲过，TCP 使用累计确认，这看起来像是 GBN 的风格。但是，正确收到但失序的报文并不会丢弃，而是缓存起来，并且发送冗余 ACK 指明期望收到的下一个报文段，这是 TCP 方式和 GBN 的显著区别。例如，A 发送了 N 个报文段，其中第 k(k<N) 个报文段丢失，其余 N-1 个报文段正确地按序到达接收方 B。使用 GBN 时，A 需要重传分组 k，及所有后继分组 k+1, k+2, …, N。相反，TCP 却至多重传一个报文段，即报文段 k。另外，TCP 中提供一个 SACK(Selective ACK) 选项，即选择确认选项。使用选择确认选项时，TCP 看起来就和 SR 非常相似。因此，TCP 的差错恢复机制可视为 GBN 和 SR 协议的混合体。

5. 为什么超时时间发生时 cwnd 被置为 1，而收到 3 个冗余 ACK 时 cwnd 减半。

   大家可以从如下角度考虑。超时事件发生和收到 3 个冗余 ACK，哪个意味着网络拥塞程度更严重？通过分析不难发现，在收到 3 个冗余 ACK 的情況下，网络虽然拥塞，但至少还有 ACK 报文段能被正确交付。而当超时发生时，说明网络可能已经拥塞得连 ACK 报文段都传输不了，发送方只能等待超时后重传数据。因此，超时时间发生时，网络拥塞更严重，那么发送方就应该最大限度地抑制数据发送量，所以 cwnd 置为 1；收到 3 个冗余 ACK 时，网络拥塞不是很严重，发送方稍微抑制一下发送的数据量即可，所以 cwnd 减半。

6. 为什么不采用 “两次提手” 建立连接呢？

   这主要是为了防止两次握手情况下已失效的连接请求报文段突然又传送到服务端而产生错误。考虑下面这种情况。客户 A 向服务器 B 发出 TCP 连接请求，第一个连接请求报文在网络的某个结点长时间滞留，A 超时后认为报文丢失，于是再重传一次连接请求，B 收到后建立连数据传输完毕后双方断开连接。而此时，前一个滞留在网络中的连接请求到达服务端 B，而 B 认为 A 又发来连接请求，此时若使用 “三次握手”，则 B 向 A 返回确认报文段，由于是一个失效的请求，因此 A 不予理睬，建立连接失败。若采用的是 “两次握手”，则这种情况下 B 认为传输连接已经建立，并一直等待 A 传输数据，而 A 此时并无连接请求，因此不予理睬，这样就造成了 B 
   的资源白白浪费。

7. 是否 TCP 和 UDP 都需要计算往返时间 RTT？

   往返时间 RTT 仅对传输层 TCP 协议才很重要，因为 TCP 要根据 RTT 的值来设置超时计时器的超时时间。

   UDP 没有确认和重传机制，因此 RTT 对 UDP 没有什么意义。

   因此，不能笼统地说 “往返时间 RTT 对传输层来说很重要”，因为只有 TCP 才需要计算 RTT，而 UDP 不需要计算 RTT。

8. 为什么 TCP 在建立连接时不能每次都选择相同的、固定的初始序号？

   1. 假定主机 A 和 B 频繁地建立连接，传送一些 TCP 报文段后，再释放连接，然后又不断地建立新的连接、传送报文段和释放连接。
   2. 假定每次建立连接时，主机 A 都选择相同的、固定的初始序号，如选择 1。
   3. 假定主机 A 发出的某些 TCP 报文段在网络中会滞留较长时间，以致主机 A 超时重传这些 TCP 报文段。
   4. 假定有一些在网络中滞留时间较长的 TCP 报文段最后终于到达主机 B，但这时传送该报文段的那个连接早已释放，而在到达主机 B 时的 TCP 连接是一条新的 TCP 连接。

   这样，工作在新的 TCP 连接的主机 B 就有可能会接收在旧的连接传送的、已无意义的、过时的 TCP 报文段（因为这个 TCP 报文段的序号有可能正好处在当前新连接所用的序号范围之中），结果产生错误。

   因此，必须使得退到的 TCP 报文段的序号不处在新连接所用的序号范围之中。

   这样，TCP 在建立新的连接时所选择的初始序号一定要和前面的一些连接所用过的序号不同。因此，不同的 TCP 连接不能使用相同的初始序号。

9. 假定在一个互联网中，所有链路的传输都不出现差错，所有结点也都不会发生故障。试问在这种情况下，TCP 的 “可靠交付” 的功能是否就是多余的？

   不是多余的。TCP 的 “可靠交付” 功能在互联网中起着至关重要的作用。至少在以下的情况下，TCP 的 “可靠交付” 功能是必不可少的。

   1. 每个 IP 数据报独立地选择路由，因此在到达目的主机时有可能出现失序。
   2. 由于路由选择的计算出现错误，导致 IP 数据报在互联网中转圈。最后数据报首部中的生存时间（TTL）的数值下降到零。这个数据报在中途就被丢失。
   3. 某个路由器突然出现很大的通信量，以致路由器来不及处理到达的数据报。因此有的数据报被丢弃。

   以上列举的问题表明：必须依靠 TCP 的 “可靠交付” 功能才能保证在目的主机的目的进程中接收到正确的报文。