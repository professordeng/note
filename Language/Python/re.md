---
title: 正则表达式
---

正则表达式有什么用？

典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。通过使用正则表达式，可以

- 测试字符串内的模式

  可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。

- 替代文本

  可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。

- 基于模式匹配从字符串中提取子字符串。

  可以查找文档内或输入域内特定的文本。（vim 查找模式）

您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。

## 实例

正则表达式（Regular Expression）是一种文本模式，包括普通符号（a~z）和特殊字符。

正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。

正则表达式繁琐但强大，学习一种东西只是为了获取某个需求（不然我也不会学）。多数语言都支持利用正则表达式进行字符串操作，由于我有现成的 `python` 环境，因此这里用 `python` 为例学习正则表达式。

例如，从字符串中找到数字串

```python
import re

str = 'abc123def'
parttern =  '[0-9]+'
searchObj = re.search(parttern, str)
print(searchObj.group())
```

## 简介

在 `Linux` 某目录下查找所有 `cpp` 后缀的文件时，我们会用 `ls *.cpp` ，这里的 `*` 就是通配符。 `*` 通配符匹配零个或多个字符。通过通配符引入正则表达式的学习。如下例子

```python
^[0-9]+abc$
```

- `^ 为匹配输入字符串的开始位置` 。
- `[0-9]+` 匹配多个数字，`[0-9]` 匹配单个数字，`+` 匹配一个或者多个。
- `abc$` 匹配字母 `abc` 并以 `abc` 结尾，`$` 为匹配输入字符串的结束位置。

我们在写用户注册表单时，只允许用户名包含字符、数字、下划线和连接符 `-` ，并设置用户名的长度，我们就可以使用以下正则表达式来设定。

```python
^[a-z0-9_-]{3,15}$
```

- `{3,15}` 表示 3~15 字符的长度
- `$` 表示结束标志

以上正则表达式可以匹配 `professordeng` 、`deng_shuai` 、 `deng11` 、但是不能匹配 `dd`，因为太短了。 

## 发展历史

正则表达式原先被用来描述神经网络，后来被发现可以将其应用在计算搜索算法，正则表达式的应用程序包括 Linux 中大名鼎鼎的 vim 编辑器。

现在正则表达式被用到各类开发环境，各种语言，包括 C++、python、vim。

| 命令或环境 | `.`  | `[]` | `^`  | `$`  | `\(\)` | `\{\}` | `?`  | `+`  | `|`  | `()` |
| ---------- | ---- | ---- | ---- | ---- | ------ | ------ | ---- | ---- | ---- | ---- |
| vim        | ✔    | ✔    | ✔    | ✔    | ✔      |        |      |      |      |      |
| c++        | ✔    | ✔    | ✔    | ✔    | ✔      |        |      |      |      |      |
| python     | ✔    | ✔    | ✔    | ✔    | ✔      | ✔      | ✔    | ✔    | ✔    | ✔    |

## 语法

正则表达式（regular expression）描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某子串中取出符合某个条件的子串等。

- `professo+r` ，可以匹配 `professor` 、 `professoor` ，`+` 号代表前面的字符出现 1 次或多次。
- `professo*r` ，可以匹配 `professr` 、`professor` 、`professoor` ，`*` 号代表前面的字符出现 0 次、1次或多次。
- `colou?r` ，可以匹配 `color` 或者 `colour`，`?` 号代表前面的字符可以出现 0 次或 1 次。

构造正则表达式的方法类似创建数学表达式，可以将正则表达式符号进行任意组合形成不同的正则表达式。

正则表达式的符号包括：普通符号（例如 a~z）和特殊符号（元符号）。

### 普通符号

没有显式指定为元符号的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有有标点符号和一些其他符号

- 非打印字符

  正则表达式的组成部分，下面列出了表示非打印字符的转义序列。

  | 字符  | 描述                                                         |
  | ----- | ------------------------------------------------------------ |
  | `\cx` | 匹配由 x 指明的控制字符。例如，`\cM` 匹配一个 Control-M 或回车符。x 的值必须为 A~Z 或  a~z 之一。否则，将 c 视为一个原义的 c 字符。 |
  | `\f`  | 匹配一个换页符。等价于 `\x0c` 和 `\cL` 。                    |
  | `\n`  | 匹配一个换行符。等价于 `\x0a` 和 `\cJ` 。                    |
  | `\r`  | 匹配一个回车符。等价于 `\x0d` 和 `\cM` 。                    |
  | `\s`  | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于`[\f\n\r\t\v]` 。注意 Unicode 正则表达式会匹配全角空格符 |
  | `\S`  | 匹配任何非空白字符。等价于 `[^\f\n\r\t\v]` 。                |
  | `\t`  | 匹配一个制表符。等价于 `\x09` 和 `\cl` 。                    |
  | `\v`  | 匹配一个垂直制表符。等价于 `\x0b` 和 `\cK`                   |

### 特殊字符

有特殊含义的字符，如上面说的 `professo*r` 中的 `*` ，简单的说就是表示任何字符串的意思。如果要查找字符串中的 `*` 号，则需要对 `*` 进行转义，即在其前面加上 `\` : `professo\*r` 匹配 `professo*r` 。也就是说，要匹配特殊字符，首先对特殊字符转义。

| 特别字符 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| `$`      | 匹配输入字符串的结尾位置。如果设置了 `RegExp` 对象的 `Multiline` 属性，则 `$` 也匹配 `\n` 或 `\r` 。要匹配 `$` 字符本身，请使用 `\$` |
| `()`     | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 `\(` 和 `\)` 。 |
| `*`      | 匹配前面的子表达式 0 次或多次。要匹配 `*` 字符，请使用 `\*` 。 |
| `+`      | 匹配前面的子表达式 1 次或多次。要匹配 `+` 字符，请使用 `\+` 。 |
| `.`      | 匹配除换行符 `\n` 之外的任何单字符。要匹配 `.` ，请使用 `\.` 。 |
| `[`      | 标记一个中括号表达式的开始。要匹配 `[` ，请使用 `\[` 。      |
| `?`      | 匹配前面的子表达式 0 次或 1 次，或指明一个非贪婪限定符。要匹配 `?` 字符，请使用 `\?` 。 |
| `\`      | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， n 匹配字符 n。`\n` 匹配换行符。序列 `\\` 匹配 `\` ，而 `\(` 匹配 `(` |
| `^`      | 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 `^` 字符本身，请使用 `\^` 。 |
| `{`      | 标记限定符表达式的开始。要匹配 `{` ，请使用 `\{` 。          |
| `|`      | 指明两项之间的一个选择。要匹配 `|` ，请使用 `\|` 。          |

### 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 `*` 或 `+` 或 `?` 或 `{n}` 或 `{n,}` 或 `{n,m}` 共 6 种。

| 字符    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| `*`     | 匹配前面的子表达式零次或多次。例如，`zo*` 匹配 `z` 以及 `zoo` 。`*` 等价于 `{0,}` 。 |
| `+`     | 匹配前面的子表达式零次或多次。例如，`zo+` 能匹配 `zo` 以及 `zoo` ，但不能匹配 `z` 。`+` 等价于`{1,}` |
| `?`     | 匹配前面的子表达式零次或一次。例如，`do(es)?` 可以匹配 `do` 、`does` 以及 `doxy` 中的 `do` 。 `?` 等价于 `{0,1}` 。 |
| `{n}`   | n 是一个非负整数。匹配确定的 n 次。例如，`o{2}` 不能匹配 `Bob` 中的 `o` ，但是能匹配 `food` 中的两个 `o` 。 |
| `{n,}`  | n 是一个非负整数。至少匹配 n 次。例如 `o{2,}` 不能匹配 `Bob` 的 `o` ，但能匹配 `foooood` 中的所有 `o` 。`o{1,}` 等价于 `o+` 。`o{0,}` 则等价于 `o*` 。 |
| `{n,m}` | m 和 n 均为非负整数，其中 `n<=m` 。最少匹配 n 次且最多匹配 m 次。例如，`o{1,3}` 将匹配 `foooood` 中的前三个 `o` 。`o{0,1}` 等价于 `o?` 。请注意在逗号和两个数之间不能有空格。 |

由于章节编号在在大的输入文档中很可能超过九，所以您需要一种方式来处理两位或三位章节编号。限定符给您这种能力。下面的正则表达式匹配编号为任何位数的章节标题：

```python
/Chapter [1-9][0-9]*/
```

## 参考资料

- [在线检验正则表达式](<http://tool.oschina.net/regex/#>)

